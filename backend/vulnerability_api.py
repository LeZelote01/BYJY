#!/usr/bin/env python3
"""
CyberSec Assistant Portable - Vulnerability API V1.0
Phase 4.1: REST API for Vulnerability Scanner
Architecture: FastAPI + CVE Database + Real-time Scanning
"""

import asyncio
import json
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any
from pathlib import Path

from fastapi import APIRouter, HTTPException, BackgroundTasks, Depends, Query
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field, validator

# Import our vulnerability scanner
from vulnerability_scanner import get_vulnerability_scanner, CVEEntry, VulnerabilityMatch

logger = logging.getLogger(__name__)

# API Router
router = APIRouter(prefix="/api/vulnerability", tags=["vulnerability"])

# Pydantic Models
class VulnerabilityScanRequest(BaseModel):
    """Request model for vulnerability scan"""
    target: str = Field(..., description="Target host or network to scan")
    scan_type: str = Field(default="comprehensive", description="Type of scan: quick, comprehensive, stealth")
    include_exploits: bool = Field(default=True, description="Include exploit information")
    max_cves_per_service: int = Field(default=50, description="Maximum CVEs to report per service")

class CVESearchRequest(BaseModel):
    """Request model for CVE search"""
    service_name: str = Field(..., description="Service name to search for")
    version: Optional[str] = Field(None, description="Specific version to search")
    severity_filter: Optional[str] = Field(None, description="Filter by severity: LOW, MEDIUM, HIGH, CRITICAL")
    limit: int = Field(default=50, description="Maximum results to return")

class DatabaseUpdateRequest(BaseModel):
    """Request model for database update"""
    days_back: int = Field(default=7, description="Days back to fetch CVE updates")
    force_update: bool = Field(default=False, description="Force update even if recently updated")

class CVEResponse(BaseModel):
    """Response model for CVE information"""
    cve_id: str
    description: str
    cvss_score: float
    severity: str
    published_date: str
    exploit_available: bool
    references: List[str]

class VulnerabilityMatchResponse(BaseModel):
    """Response model for vulnerability match"""
    target_host: str
    target_port: int
    service_name: str
    service_version: str
    risk_level: str
    confidence_score: float
    cve_count: int
    cves: List[CVEResponse]
    recommendations: List[str]

class ScanStatusResponse(BaseModel):
    """Response model for scan status"""
    scan_id: str
    target: str
    status: str
    start_time: str
    end_time: Optional[str] = None
    progress_percentage: int = 0
    total_vulnerabilities: int = 0
    critical_count: int = 0
    high_count: int = 0
    medium_count: int = 0
    low_count: int = 0
    estimated_completion: Optional[str] = None

# Dependency to get vulnerability scanner
def get_scanner() -> Any:
    """Dependency to get vulnerability scanner instance"""
    try:
        return get_vulnerability_scanner()
    except Exception as e:
        logger.error(f"Failed to get vulnerability scanner: {e}")
        raise HTTPException(status_code=500, detail="Vulnerability scanner unavailable")

# API Endpoints

@router.post("/scan/start", response_model=Dict[str, Any])
async def start_vulnerability_scan(
    request: VulnerabilityScanRequest,
    background_tasks: BackgroundTasks,
    scanner = Depends(get_scanner)
):
    """Start a new vulnerability scan"""
    try:
        # Validate scan type
        valid_scan_types = ["quick", "comprehensive", "stealth", "web", "network"]
        if request.scan_type not in valid_scan_types:
            raise HTTPException(status_code=400, detail=f"Invalid scan type. Must be one of: {valid_scan_types}")
        
        # Start the scan
        scan_id = await scanner.start_vulnerability_scan(
            target=request.target,
            scan_type=request.scan_type
        )
        
        logger.info(f"üöÄ Started vulnerability scan {scan_id} for {request.target}")
        
        return {
            "status": "success",
            "scan_id": scan_id,
            "message": f"Vulnerability scan started for {request.target}",
            "target": request.target,
            "scan_type": request.scan_type,
            "estimated_duration": "5-15 minutes"
        }
        
    except Exception as e:
        logger.error(f"‚ùå Failed to start vulnerability scan: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/scan/{scan_id}/status", response_model=ScanStatusResponse)
async def get_scan_status(
    scan_id: str,
    scanner = Depends(get_scanner)
):
    """Get status of a vulnerability scan"""
    try:
        status = scanner.get_scan_status(scan_id)
        
        if "error" in status:
            raise HTTPException(status_code=404, detail=status["error"])
        
        # Calculate progress percentage
        progress = 100 if status["status"] in ["completed", "failed"] else 50
        
        response = ScanStatusResponse(
            scan_id=status["scan_id"],
            target=status["target"],
            status=status["status"],
            start_time=status["start_time"],
            end_time=status.get("end_time"),
            progress_percentage=progress,
            total_vulnerabilities=status.get("total_vulnerabilities", 0),
            critical_count=status.get("critical_count", 0),
            high_count=status.get("high_count", 0),
            medium_count=status.get("medium_count", 0),
            low_count=status.get("low_count", 0)
        )
        
        return response
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚ùå Failed to get scan status: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/scan/{scan_id}/results", response_model=Dict[str, Any])
async def get_scan_results(
    scan_id: str,
    severity_filter: Optional[str] = Query(None, description="Filter by severity"),
    limit: int = Query(100, description="Maximum results to return"),
    scanner = Depends(get_scanner)
):
    """Get detailed results of a vulnerability scan"""
    try:
        # Get basic scan status first
        status = scanner.get_scan_status(scan_id)
        if "error" in status:
            raise HTTPException(status_code=404, detail=status["error"])
        
        # Get detailed vulnerability information
        vulnerabilities = scanner.get_vulnerability_details(scan_id)
        
        # Apply severity filter if requested
        if severity_filter:
            severity_filter = severity_filter.upper()
            vulnerabilities = [
                v for v in vulnerabilities 
                if v.get("risk_level", "").upper() == severity_filter
            ]
        
        # Limit results
        vulnerabilities = vulnerabilities[:limit]
        
        # Format response
        formatted_vulns = []
        for vuln in vulnerabilities:
            cve_info = vuln.get("cve", {})
            formatted_vuln = VulnerabilityMatchResponse(
                target_host=vuln["target_host"],
                target_port=vuln["target_port"],
                service_name=vuln["service_name"],
                service_version=vuln["service_version"],
                risk_level=vuln["risk_level"],
                confidence_score=vuln["confidence_score"],
                cve_count=1,  # Each row is one CVE
                cves=[CVEResponse(
                    cve_id=cve_info["cve_id"],
                    description=cve_info["description"],
                    cvss_score=cve_info["cvss_score"],
                    severity=cve_info["severity"],
                    published_date=cve_info["published_date"],
                    exploit_available=cve_info["exploit_available"],
                    references=cve_info["references"]
                )],
                recommendations=vuln["recommendations"]
            )
            formatted_vulns.append(formatted_vuln)
        
        return {
            "scan_info": status,
            "vulnerabilities": [v.dict() for v in formatted_vulns],
            "total_shown": len(formatted_vulns),
            "filters_applied": {
                "severity_filter": severity_filter,
                "limit": limit
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚ùå Failed to get scan results: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/scan/list", response_model=Dict[str, Any])
async def list_vulnerability_scans(
    limit: int = Query(50, description="Maximum scans to return"),
    status_filter: Optional[str] = Query(None, description="Filter by status"),
    scanner = Depends(get_scanner)
):
    """List all vulnerability scans"""
    try:
        with scanner.db_manager.get_connection() as conn:
            cursor = conn.cursor()
            
            query = """
                SELECT scan_id, target, scan_type, status, start_time, end_time,
                       total_vulnerabilities, critical_count, high_count, medium_count, low_count
                FROM vulnerability_scans
            """
            
            params = []
            if status_filter:
                query += " WHERE status = ?"
                params.append(status_filter)
            
            query += " ORDER BY start_time DESC LIMIT ?"
            params.append(limit)
            
            cursor.execute(query, params)
            results = cursor.fetchall()
            
            scans = []
            for row in results:
                scan_info = {
                    "scan_id": row[0],
                    "target": row[1],
                    "scan_type": row[2],
                    "status": row[3],
                    "start_time": row[4],
                    "end_time": row[5],
                    "total_vulnerabilities": row[6] or 0,
                    "critical_count": row[7] or 0,
                    "high_count": row[8] or 0,
                    "medium_count": row[9] or 0,
                    "low_count": row[10] or 0
                }
                scans.append(scan_info)
            
            return {
                "scans": scans,
                "total_returned": len(scans),
                "filters_applied": {
                    "status_filter": status_filter,
                    "limit": limit
                }
            }
        
    except Exception as e:
        logger.error(f"‚ùå Failed to list scans: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/cve/search", response_model=Dict[str, Any])
async def search_cve_database(
    request: CVESearchRequest,
    scanner = Depends(get_scanner)
):
    """Search CVE database by service and version"""
    try:
        cve_entries = scanner.cve_db.search_cve_by_service(
            service=request.service_name,
            version=request.version
        )
        
        # Apply severity filter if specified
        if request.severity_filter:
            severity_filter = request.severity_filter.upper()
            cve_entries = [
                cve for cve in cve_entries
                if cve.severity.upper() == severity_filter
            ]
        
        # Limit results
        cve_entries = cve_entries[:request.limit]
        
        # Format response
        formatted_cves = []
        for cve in cve_entries:
            cve_response = CVEResponse(
                cve_id=cve.cve_id,
                description=cve.description,
                cvss_score=cve.cvss_score,
                severity=cve.severity,
                published_date=cve.published_date,
                exploit_available=cve.exploit_available,
                references=cve.references
            )
            formatted_cves.append(cve_response)
        
        return {
            "search_query": {
                "service_name": request.service_name,
                "version": request.version,
                "severity_filter": request.severity_filter
            },
            "cves": [cve.dict() for cve in formatted_cves],
            "total_found": len(formatted_cves),
            "search_timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"‚ùå CVE search failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/cve/{cve_id}", response_model=Dict[str, Any])
async def get_cve_details(
    cve_id: str,
    scanner = Depends(get_scanner)
):
    """Get detailed information about a specific CVE"""
    try:
        with scanner.db_manager.get_connection() as conn:
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT cve_id, description, cvss_score, cvss_vector, severity,
                       published_date, modified_date, cpe_configurations, references,
                       exploit_available, exploit_sources
                FROM cve_entries
                WHERE cve_id = ?
            """, (cve_id,))
            
            result = cursor.fetchone()
            
            if not result:
                raise HTTPException(status_code=404, detail=f"CVE {cve_id} not found")
            
            # Get related exploits
            cursor.execute("""
                SELECT exploit_id, title, description, platform, exploit_type,
                       source_url, author, date_published, verified
                FROM exploit_database
                WHERE cve_id = ?
            """, (cve_id,))
            
            exploits = cursor.fetchall()
            
            exploit_info = []
            for exploit in exploits:
                exploit_info.append({
                    "exploit_id": exploit[0],
                    "title": exploit[1],
                    "description": exploit[2],
                    "platform": exploit[3],
                    "exploit_type": exploit[4],
                    "source_url": exploit[5],
                    "author": exploit[6],
                    "date_published": exploit[7],
                    "verified": bool(exploit[8])
                })
            
            cve_details = {
                "cve_id": result[0],
                "description": result[1],
                "cvss_score": result[2],
                "cvss_vector": result[3],
                "severity": result[4],
                "published_date": result[5],
                "modified_date": result[6],
                "cpe_configurations": json.loads(result[7]) if result[7] else [],
                "references": json.loads(result[8]) if result[8] else [],
                "exploit_available": bool(result[9]),
                "exploit_sources": json.loads(result[10]) if result[10] else [],
                "exploits": exploit_info
            }
            
            return cve_details
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚ùå Failed to get CVE details: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/database/update", response_model=Dict[str, Any])
async def update_cve_database(
    request: DatabaseUpdateRequest,
    background_tasks: BackgroundTasks,
    scanner = Depends(get_scanner)
):
    """Update CVE database from NIST NVD"""
    try:
        # Add update task to background
        background_tasks.add_task(
            _background_database_update, 
            scanner, 
            request.days_back,
            request.force_update
        )
        
        logger.info(f"üîÑ Started CVE database update task ({request.days_back} days back)")
        
        return {
            "status": "success",
            "message": "CVE database update started",
            "days_back": request.days_back,
            "force_update": request.force_update,
            "estimated_duration": "2-5 minutes"
        }
        
    except Exception as e:
        logger.error(f"‚ùå Failed to start database update: {e}")
        raise HTTPException(status_code=500, detail=str(e))

async def _background_database_update(scanner, days_back: int, force_update: bool):
    """Background task for CVE database update"""
    try:
        result = await scanner.cve_db.update_cve_database(days_back=days_back)
        logger.info(f"‚úÖ CVE database update completed: {result}")
    except Exception as e:
        logger.error(f"‚ùå Background CVE database update failed: {e}")

@router.get("/database/stats", response_model=Dict[str, Any])
async def get_database_stats(scanner = Depends(get_scanner)):
    """Get CVE database statistics"""
    try:
        with scanner.db_manager.get_connection() as conn:
            cursor = conn.cursor()
            
            # Count total CVEs
            cursor.execute("SELECT COUNT(*) FROM cve_entries")
            total_cves = cursor.fetchone()[0]
            
            # Count by severity
            cursor.execute("""
                SELECT severity, COUNT(*) as count
                FROM cve_entries
                GROUP BY severity
                ORDER BY count DESC
            """)
            severity_counts = dict(cursor.fetchall())
            
            # Count CVEs with exploits
            cursor.execute("SELECT COUNT(*) FROM cve_entries WHERE exploit_available = 1")
            cves_with_exploits = cursor.fetchone()[0]
            
            # Get most recent CVE
            cursor.execute("""
                SELECT cve_id, published_date 
                FROM cve_entries 
                ORDER BY published_date DESC 
                LIMIT 1
            """)
            latest_cve = cursor.fetchone()
            
            # Count total scans
            cursor.execute("SELECT COUNT(*) FROM vulnerability_scans")
            total_scans = cursor.fetchone()[0]
            
            # Count scans by status
            cursor.execute("""
                SELECT status, COUNT(*) as count
                FROM vulnerability_scans
                GROUP BY status
            """)
            scan_status_counts = dict(cursor.fetchall())
            
            stats = {
                "cve_database": {
                    "total_cves": total_cves,
                    "severity_breakdown": severity_counts,
                    "cves_with_exploits": cves_with_exploits,
                    "latest_cve": {
                        "cve_id": latest_cve[0] if latest_cve else None,
                        "published_date": latest_cve[1] if latest_cve else None
                    }
                },
                "scan_history": {
                    "total_scans": total_scans,
                    "status_breakdown": scan_status_counts
                },
                "last_updated": datetime.now().isoformat()
            }
            
            return stats
        
    except Exception as e:
        logger.error(f"‚ùå Failed to get database stats: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.delete("/scan/{scan_id}", response_model=Dict[str, Any])
async def delete_scan_results(
    scan_id: str,
    scanner = Depends(get_scanner)
):
    """Delete vulnerability scan results"""
    try:
        with scanner.db_manager.get_connection() as conn:
            cursor = conn.cursor()
            
            # Check if scan exists
            cursor.execute("SELECT COUNT(*) FROM vulnerability_scans WHERE scan_id = ?", (scan_id,))
            if cursor.fetchone()[0] == 0:
                raise HTTPException(status_code=404, detail="Scan not found")
            
            # Delete vulnerability matches first (foreign key constraint)
            cursor.execute("DELETE FROM vulnerability_matches WHERE scan_id = ?", (scan_id,))
            matches_deleted = cursor.rowcount
            
            # Delete scan record
            cursor.execute("DELETE FROM vulnerability_scans WHERE scan_id = ?", (scan_id,))
            scan_deleted = cursor.rowcount
            
            conn.commit()
            
            # Remove from active scans if present
            if scan_id in scanner._active_scans:
                del scanner._active_scans[scan_id]
            
            logger.info(f"üóëÔ∏è Deleted scan {scan_id}: {matches_deleted} matches, {scan_deleted} scan record")
            
            return {
                "status": "success",
                "message": f"Scan {scan_id} deleted successfully",
                "deleted_matches": matches_deleted,
                "deleted_scan": scan_deleted
            }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚ùå Failed to delete scan: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/health", response_model=Dict[str, Any])
async def vulnerability_health_check(scanner = Depends(get_scanner)):
    """Health check for vulnerability scanner"""
    try:
        # Test database connection
        with scanner.db_manager.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM cve_entries")
            cve_count = cursor.fetchone()[0]
        
        # Check active scans
        active_scans = len(scanner._active_scans)
        
        return {
            "status": "healthy",
            "vulnerability_scanner": "operational",
            "database": {
                "connected": True,
                "cve_entries": cve_count
            },
            "active_scans": active_scans,
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"‚ùå Vulnerability health check failed: {e}")
        raise HTTPException(status_code=500, detail=f"Health check failed: {e}")

# WebSocket endpoint for real-time scan updates (to be implemented)
@router.websocket("/ws/scan/{scan_id}")
async def scan_websocket(websocket, scan_id: str):
    """WebSocket endpoint for real-time scan updates"""
    # This would provide real-time updates during scanning
    # Implementation depends on WebSocket infrastructure
    pass

if __name__ == "__main__":
    print("Vulnerability API module loaded successfully")
    print("Available endpoints:")
    for route in router.routes:
        if hasattr(route, 'methods') and hasattr(route, 'path'):
            methods = list(route.methods)
            print(f"  {methods[0]:6} {route.path}")