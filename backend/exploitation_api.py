#!/usr/bin/env python3
"""
CyberSec Assistant Portable - Exploitation API V1.0
Phase 6.1 - API REST pour le framework d'exploitation
"""

import asyncio
import json
import logging
from datetime import datetime
from typing import Dict, List, Any, Optional
from fastapi import APIRouter, HTTPException, BackgroundTasks, Depends
from pydantic import BaseModel, Field

# Import du framework d'exploitation
from exploitation_framework import get_global_exploitation_framework

logger = logging.getLogger(__name__)

# Router
router = APIRouter(
    prefix="/api/exploitation",
    tags=["exploitation"],
    responses={404: {"description": "Not found"}}
)

# Pydantic models
class PayloadGenerationRequest(BaseModel):
    payload_type: str = Field(..., description="Type de payload (reverse_shell, bind_shell, web_shell, meterpreter)")
    payload_subtype: str = Field(..., description="Sous-type de payload (bash, python, powershell, php, etc.)")
    config: Dict[str, Any] = Field(..., description="Configuration du payload (host, port, etc.)")
    obfuscate: bool = Field(True, description="Appliquer l'obfuscation")

class ExploitExecutionRequest(BaseModel):
    exploit_category: str = Field(..., description="Catégorie d'exploit (web, network, windows, linux)")
    exploit_name: str = Field(..., description="Nom de l'exploit")
    target: str = Field(..., description="Cible de l'exploitation")
    config: Dict[str, Any] = Field(default_factory=dict, description="Configuration de l'exploit")

class SessionCreationRequest(BaseModel):
    target: str = Field(..., description="Cible de la session")
    session_type: str = Field(..., description="Type de session (reverse_shell, meterpreter, web_shell)")
    config: Dict[str, Any] = Field(default_factory=dict, description="Configuration de la session")

class SessionCommandRequest(BaseModel):
    command: str = Field(..., description="Commande à exécuter")

# Obtenir l'instance du framework
exploitation_framework = get_global_exploitation_framework()

# Endpoints

@router.get("/")
async def get_exploitation_info():
    """Informations sur le framework d'exploitation"""
    try:
        stats = await exploitation_framework.get_exploitation_statistics()
        
        return {
            "status": "operational",
            "version": "1.0",
            "framework": "Advanced Exploitation Framework",
            "capabilities": [
                "payload_generation",
                "exploit_execution", 
                "session_management",
                "post_exploitation",
                "stealth_integration"
            ],
            "statistics": stats,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        logger.error(f"Failed to get exploitation info: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/exploits/database")
async def get_exploits_database():
    """Obtenir la base de données d'exploits"""
    try:
        database = exploitation_framework.get_exploits_database()
        
        # Count exploits by category
        stats = {}
        total_exploits = 0
        
        for category, exploits in database["categories"].items():
            stats[category] = len(exploits)
            total_exploits += len(exploits)
        
        return {
            "database": database,
            "statistics": {
                "total_exploits": total_exploits,
                "categories": stats,
                "version": database.get("version", "1.0")
            }
        }
    except Exception as e:
        logger.error(f"Failed to get exploits database: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/exploits/categories")
async def get_exploit_categories():
    """Obtenir les catégories d'exploits disponibles"""
    try:
        database = exploitation_framework.get_exploits_database()
        categories = []
        
        for category_name, exploits in database["categories"].items():
            category_info = {
                "name": category_name,
                "exploits_count": len(exploits),
                "exploits": []
            }
            
            for exploit_name, exploit_data in exploits.items():
                category_info["exploits"].append({
                    "name": exploit_name,
                    "display_name": exploit_data.get("name", exploit_name),
                    "description": exploit_data.get("description", ""),
                    "severity": exploit_data.get("severity", "medium"),
                    "techniques_count": len(exploit_data.get("techniques", [])),
                    "payloads_count": len(exploit_data.get("payloads", []))
                })
            
            categories.append(category_info)
        
        return {"categories": categories}
    except Exception as e:
        logger.error(f"Failed to get exploit categories: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/exploits/{category}/{exploit_name}")
async def get_exploit_details(category: str, exploit_name: str):
    """Obtenir les détails d'un exploit spécifique"""
    try:
        database = exploitation_framework.get_exploits_database()
        
        if category not in database["categories"]:
            raise HTTPException(status_code=404, detail=f"Category not found: {category}")
        
        if exploit_name not in database["categories"][category]:
            raise HTTPException(status_code=404, detail=f"Exploit not found: {exploit_name}")
        
        exploit_data = database["categories"][category][exploit_name]
        
        return {
            "category": category,
            "name": exploit_name,
            "details": exploit_data
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get exploit details: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/exploits/execute")
async def execute_exploit(request: ExploitExecutionRequest, background_tasks: BackgroundTasks):
    """Exécuter un exploit contre une cible"""
    try:
        logger.info(f"Starting exploit execution: {request.exploit_category}/{request.exploit_name} -> {request.target}")
        
        # Execute exploit
        result = await exploitation_framework.execute_exploit(
            request.exploit_category,
            request.exploit_name,
            request.target,
            request.config
        )
        
        return {
            "message": "Exploit execution completed",
            "execution": result
        }
    except Exception as e:
        logger.error(f"Exploit execution failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/payloads/templates")
async def get_payload_templates():
    """Obtenir les templates de payloads disponibles"""
    try:
        templates = exploitation_framework.get_payload_templates()
        
        # Format templates for display
        formatted_templates = {}
        for payload_type, subtypes in templates.items():
            formatted_templates[payload_type] = {
                "subtypes": list(subtypes.keys()),
                "description": {
                    "reverse_shell": "Shell inversé pour connexion sortante",
                    "bind_shell": "Shell lié pour connexion entrante", 
                    "web_shell": "Shell web pour exécution via HTTP",
                    "meterpreter": "Payload Meterpreter avancé"
                }.get(payload_type, "Payload personnalisé")
            }
        
        return {
            "templates": formatted_templates,
            "total_types": len(templates),
            "supported_languages": ["bash", "python", "powershell", "php", "jsp", "aspx"]
        }
    except Exception as e:
        logger.error(f"Failed to get payload templates: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/payloads/generate")
async def generate_payload(request: PayloadGenerationRequest):
    """Générer un payload personnalisé"""
    try:
        logger.info(f"Generating payload: {request.payload_type}/{request.payload_subtype}")
        
        payload_info = await exploitation_framework.generate_payload(
            request.payload_type,
            request.payload_subtype,
            request.config,
            request.obfuscate
        )
        
        return {
            "message": "Payload generated successfully",
            "payload": payload_info
        }
    except Exception as e:
        logger.error(f"Payload generation failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/sessions")
async def get_active_sessions():
    """Obtenir les sessions d'exploitation actives"""
    try:
        sessions = exploitation_framework.get_active_sessions()
        
        # Format sessions for display
        formatted_sessions = []
        for session_id, session_data in sessions.items():
            formatted_sessions.append({
                "id": session_id,
                "target": session_data["target"],
                "type": session_data["type"],
                "status": session_data["status"],
                "created_at": session_data["created_at"],
                "last_activity": session_data["last_activity"],
                "commands_count": len(session_data.get("commands_executed", [])),
                "files_uploaded": len(session_data.get("files_uploaded", [])),
                "files_downloaded": len(session_data.get("files_downloaded", []))
            })
        
        return {
            "sessions": formatted_sessions,
            "total_sessions": len(formatted_sessions)
        }
    except Exception as e:
        logger.error(f"Failed to get active sessions: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/sessions/create")
async def create_session(request: SessionCreationRequest):
    """Créer une nouvelle session d'exploitation"""
    try:
        logger.info(f"Creating exploitation session: {request.session_type} -> {request.target}")
        
        session_data = await exploitation_framework.create_session(
            request.target,
            request.session_type,
            request.config
        )
        
        return {
            "message": "Session created successfully",
            "session": session_data
        }
    except Exception as e:
        logger.error(f"Session creation failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/sessions/{session_id}")
async def get_session_details(session_id: str):
    """Obtenir les détails d'une session spécifique"""
    try:
        sessions = exploitation_framework.get_active_sessions()
        
        if session_id not in sessions:
            raise HTTPException(status_code=404, detail=f"Session not found: {session_id}")
        
        session_data = sessions[session_id]
        
        return {
            "session": session_data
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get session details: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/sessions/{session_id}/execute")
async def execute_session_command(session_id: str, request: SessionCommandRequest):
    """Exécuter une commande dans une session"""
    try:
        logger.info(f"Executing command in session {session_id}: {request.command[:50]}...")
        
        result = await exploitation_framework.execute_session_command(
            session_id,
            request.command
        )
        
        return {
            "message": "Command executed successfully",
            "result": result
        }
    except Exception as e:
        logger.error(f"Session command execution failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.delete("/sessions/{session_id}")
async def terminate_session(session_id: str):
    """Terminer une session d'exploitation"""
    try:
        sessions = exploitation_framework.get_active_sessions()
        
        if session_id not in sessions:
            raise HTTPException(status_code=404, detail=f"Session not found: {session_id}")
        
        # Mark session as terminated
        sessions[session_id]["status"] = "terminated"
        sessions[session_id]["terminated_at"] = datetime.now().isoformat()
        
        # Remove from active sessions
        del sessions[session_id]
        
        return {
            "message": "Session terminated successfully",
            "session_id": session_id
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Session termination failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/sessions/cleanup")
async def cleanup_old_sessions(older_than_hours: int = 24):
    """Nettoyer les anciennes sessions"""
    try:
        cleaned_sessions = await exploitation_framework.cleanup_sessions(older_than_hours)
        
        return {
            "message": f"Cleaned up {len(cleaned_sessions)} old sessions",
            "cleaned_sessions": cleaned_sessions,
            "older_than_hours": older_than_hours
        }
    except Exception as e:
        logger.error(f"Session cleanup failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/statistics")
async def get_exploitation_statistics():
    """Obtenir les statistiques d'exploitation"""
    try:
        stats = await exploitation_framework.get_exploitation_statistics()
        
        return {
            "statistics": stats,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        logger.error(f"Failed to get exploitation statistics: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/health")
async def health_check():
    """Vérification de l'état du framework d'exploitation"""
    try:
        stats = await exploitation_framework.get_exploitation_statistics()
        
        return {
            "status": "healthy",
            "version": "1.0",
            "framework": "Exploitation Framework",
            "active_sessions": stats.get("active_sessions", 0),
            "total_exploits": stats.get("total_exploits", 0),
            "uptime": "running",
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))