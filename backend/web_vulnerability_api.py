#!/usr/bin/env python3
"""
CyberSec Assistant Portable - Web Vulnerability API V1.0
Phase 4.2: REST API for Web Vulnerability Scanner (OWASP Top 10)
Architecture: FastAPI + Web Scanner + Real-time Scanning
"""

import asyncio
import json
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any
from pathlib import Path

from fastapi import APIRouter, HTTPException, BackgroundTasks, Depends, Query
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field, validator

# Import our web vulnerability scanner
from web_vulnerability_scanner import get_web_vulnerability_scanner

logger = logging.getLogger(__name__)

# API Router
router = APIRouter(prefix="/api/web-vulnerability", tags=["web-vulnerability"])

# Pydantic Models
class WebVulnerabilityScanRequest(BaseModel):
    """Request model for web vulnerability scan"""
    target_url: str = Field(..., description="Target URL to scan")
    scan_type: str = Field(default="comprehensive", description="Type of scan: quick, comprehensive, owasp, ssl, headers")
    include_ssl: bool = Field(default=True, description="Include SSL/TLS analysis")
    include_headers: bool = Field(default=True, description="Include security headers check")
    max_depth: int = Field(default=1, description="Maximum crawling depth")
    
    @validator('target_url')
    def validate_url(cls, v):
        if not (v.startswith('http://') or v.startswith('https://')):
            raise ValueError('URL must start with http:// or https://')
        return v

class WebVulnerabilityResponse(BaseModel):
    """Response model for web vulnerability"""
    vuln_id: str
    vulnerability_type: str
    severity: str
    title: str
    description: str
    url: str
    method: str
    parameter: str
    payload: str
    evidence: str
    risk_score: float
    cwe_id: Optional[str] = None
    owasp_category: Optional[str] = None
    remediation: List[str]

class WebScanStatusResponse(BaseModel):
    """Response model for web scan status"""
    scan_id: str
    target_url: str
    status: str
    start_time: str
    end_time: Optional[str] = None
    progress_percentage: int = 0
    total_vulnerabilities: int = 0
    critical_count: int = 0
    high_count: int = 0
    medium_count: int = 0
    low_count: int = 0
    pages_scanned: int = 0
    forms_found: int = 0
    ssl_grade: Optional[str] = None

class OWASPCategoryStats(BaseModel):
    """OWASP category statistics"""
    category_id: str
    category_name: str
    vulnerability_count: int
    highest_severity: str
    avg_risk_score: float

# Dependency to get web vulnerability scanner
def get_scanner() -> Any:
    """Dependency to get web vulnerability scanner instance"""
    try:
        return get_web_vulnerability_scanner()
    except Exception as e:
        logger.error(f"Failed to get web vulnerability scanner: {e}")
        raise HTTPException(status_code=500, detail="Web vulnerability scanner unavailable")

# API Endpoints

@router.post("/scan/start", response_model=Dict[str, Any])
async def start_web_vulnerability_scan(
    request: WebVulnerabilityScanRequest,
    background_tasks: BackgroundTasks,
    scanner = Depends(get_scanner)
):
    """Start a new web vulnerability scan"""
    try:
        # Validate scan type
        valid_scan_types = ["quick", "comprehensive", "owasp", "ssl", "headers"]
        if request.scan_type not in valid_scan_types:
            raise HTTPException(status_code=400, detail=f"Invalid scan type. Must be one of: {valid_scan_types}")
        
        # Start the scan
        scan_id = await scanner.start_web_scan(
            target_url=request.target_url,
            scan_type=request.scan_type
        )
        
        logger.info(f"🚀 Started web vulnerability scan {scan_id} for {request.target_url}")
        
        return {
            "status": "success",
            "scan_id": scan_id,
            "message": f"Web vulnerability scan started for {request.target_url}",
            "target_url": request.target_url,
            "scan_type": request.scan_type,
            "estimated_duration": "5-20 minutes"
        }
        
    except Exception as e:
        logger.error(f"❌ Failed to start web vulnerability scan: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/scan/{scan_id}/status", response_model=WebScanStatusResponse)
async def get_web_scan_status(
    scan_id: str,
    scanner = Depends(get_scanner)
):
    """Get status of a web vulnerability scan"""
    try:
        status = scanner.get_scan_status(scan_id)
        
        if "error" in status:
            raise HTTPException(status_code=404, detail=status["error"])
        
        # Calculate progress percentage
        progress = 100 if status["status"] in ["completed", "failed"] else 50
        
        response = WebScanStatusResponse(
            scan_id=status["scan_id"],
            target_url=status["target_url"],
            status=status["status"],
            start_time=status["start_time"],
            end_time=status.get("end_time"),
            progress_percentage=progress,
            total_vulnerabilities=status.get("total_vulnerabilities", 0),
            critical_count=status.get("critical_count", 0),
            high_count=status.get("high_count", 0),
            medium_count=status.get("medium_count", 0),
            low_count=status.get("low_count", 0),
            pages_scanned=status.get("pages_scanned", 0),
            forms_found=status.get("forms_found", 0),
            ssl_grade=status.get("ssl_grade")
        )
        
        return response
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"❌ Failed to get web scan status: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/scan/{scan_id}/results", response_model=Dict[str, Any])
async def get_web_scan_results(
    scan_id: str,
    severity_filter: Optional[str] = Query(None, description="Filter by severity"),
    owasp_category: Optional[str] = Query(None, description="Filter by OWASP category"),
    limit: int = Query(100, description="Maximum results to return"),
    scanner = Depends(get_scanner)
):
    """Get detailed results of a web vulnerability scan"""
    try:
        # Get basic scan status first
        status = scanner.get_scan_status(scan_id)
        if "error" in status:
            raise HTTPException(status_code=404, detail=status["error"])
        
        # Get detailed vulnerability information
        vulnerabilities = scanner.get_web_vulnerabilities(scan_id)
        
        # Apply filters
        if severity_filter:
            severity_filter = severity_filter.upper()
            vulnerabilities = [
                v for v in vulnerabilities 
                if v.get("severity", "").upper() == severity_filter
            ]
        
        if owasp_category:
            vulnerabilities = [
                v for v in vulnerabilities 
                if v.get("owasp_category", "") == owasp_category
            ]
        
        # Limit results
        vulnerabilities = vulnerabilities[:limit]
        
        # Format vulnerabilities for response
        formatted_vulnerabilities = []
        for vuln in vulnerabilities:
            formatted_vuln = WebVulnerabilityResponse(
                vuln_id=vuln["vuln_id"],
                vulnerability_type=vuln["vulnerability_type"],
                severity=vuln["severity"],
                title=vuln["title"],
                description=vuln["description"],
                url=vuln["url"],
                method=vuln["method"] or "GET",
                parameter=vuln["parameter"] or "",
                payload=vuln["payload"] or "",
                evidence=vuln["evidence"] or "",
                risk_score=vuln["risk_score"] or 0.0,
                cwe_id=vuln.get("cwe_id"),
                owasp_category=vuln.get("owasp_category"),
                remediation=vuln["remediation"] or []
            )
            formatted_vulnerabilities.append(formatted_vuln.dict())
        
        # Calculate OWASP category statistics
        owasp_stats = {}
        for vuln in vulnerabilities:
            category = vuln.get("owasp_category", "Unknown")
            if category not in owasp_stats:
                owasp_stats[category] = {
                    "count": 0,
                    "severities": [],
                    "risk_scores": []
                }
            owasp_stats[category]["count"] += 1
            owasp_stats[category]["severities"].append(vuln["severity"])
            owasp_stats[category]["risk_scores"].append(vuln["risk_score"] or 0.0)
        
        # Format OWASP stats
        formatted_owasp_stats = []
        owasp_names = {
            "A01:2021": "Broken Access Control",
            "A02:2021": "Cryptographic Failures",
            "A03:2021": "Injection",
            "A04:2021": "Insecure Design",
            "A05:2021": "Security Misconfiguration",
            "A06:2021": "Vulnerable and Outdated Components",
            "A07:2021": "Identification and Authentication Failures", 
            "A08:2021": "Software and Data Integrity Failures",
            "A09:2021": "Security Logging and Monitoring Failures",
            "A10:2021": "Server-Side Request Forgery (SSRF)"
        }
        
        for category, stats in owasp_stats.items():
            if stats["count"] > 0:
                severity_priority = {"CRITICAL": 4, "HIGH": 3, "MEDIUM": 2, "LOW": 1}
                highest_severity = max(stats["severities"], key=lambda x: severity_priority.get(x, 0))
                avg_risk_score = sum(stats["risk_scores"]) / len(stats["risk_scores"])
                
                owasp_stat = OWASPCategoryStats(
                    category_id=category,
                    category_name=owasp_names.get(category, category),
                    vulnerability_count=stats["count"],
                    highest_severity=highest_severity,
                    avg_risk_score=round(avg_risk_score, 2)
                )
                formatted_owasp_stats.append(owasp_stat.dict())
        
        return {
            "scan_id": scan_id,
            "status": status["status"],
            "target_url": status["target_url"],
            "total_vulnerabilities": status.get("total_vulnerabilities", 0),
            "filtered_vulnerabilities": len(formatted_vulnerabilities),
            "summary": {
                "critical": status.get("critical_count", 0),
                "high": status.get("high_count", 0),
                "medium": status.get("medium_count", 0),
                "low": status.get("low_count", 0)
            },
            "scan_info": {
                "pages_scanned": status.get("pages_scanned", 0),
                "forms_found": status.get("forms_found", 0),
                "ssl_grade": status.get("ssl_grade"),
                "start_time": status["start_time"],
                "end_time": status.get("end_time")
            },
            "owasp_statistics": formatted_owasp_stats,
            "vulnerabilities": formatted_vulnerabilities
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"❌ Failed to get web scan results: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/scan/list", response_model=Dict[str, Any])
async def list_web_vulnerability_scans(
    limit: int = Query(50, description="Maximum scans to return"),
    status_filter: Optional[str] = Query(None, description="Filter by status"),
    scanner = Depends(get_scanner)
):
    """List all web vulnerability scans"""
    try:
        with scanner.db_manager.get_connection() as conn:
            cursor = conn.cursor()
            
            # Build query with optional status filter
            query = """
                SELECT scan_id, target_url, scan_type, status, start_time, end_time,
                       total_vulnerabilities, critical_count, high_count, medium_count, low_count,
                       pages_scanned, forms_found, ssl_grade, created_at
                FROM web_vulnerability_scans
            """
            params = []
            
            if status_filter:
                query += " WHERE status = ?"
                params.append(status_filter)
            
            query += " ORDER BY created_at DESC LIMIT ?"
            params.append(limit)
            
            cursor.execute(query, params)
            results = cursor.fetchall()
            
            scans = []
            for row in results:
                scan = {
                    "scan_id": row[0],
                    "target_url": row[1],
                    "scan_type": row[2],
                    "status": row[3],
                    "start_time": row[4],
                    "end_time": row[5],
                    "total_vulnerabilities": row[6] or 0,
                    "critical_count": row[7] or 0,
                    "high_count": row[8] or 0,
                    "medium_count": row[9] or 0,
                    "low_count": row[10] or 0,
                    "pages_scanned": row[11] or 0,
                    "forms_found": row[12] or 0,
                    "ssl_grade": row[13],
                    "created_at": row[14]
                }
                scans.append(scan)
            
            return {
                "scans": scans,
                "total_count": len(scans),
                "filtered_by_status": status_filter
            }
        
    except Exception as e:
        logger.error(f"❌ Failed to list web vulnerability scans: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/vulnerability/{vuln_id}", response_model=Dict[str, Any])
async def get_vulnerability_details(
    vuln_id: str,
    scanner = Depends(get_scanner)
):
    """Get detailed information about a specific vulnerability"""
    try:
        with scanner.db_manager.get_connection() as conn:
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT wv.*, wqs.target_url, wqs.scan_type, wqs.start_time
                FROM web_vulnerabilities wv
                JOIN web_vulnerability_scans wqs ON wv.scan_id = wqs.scan_id
                WHERE wv.vuln_id = ?
            """, (vuln_id,))
            
            result = cursor.fetchone()
            if not result:
                raise HTTPException(status_code=404, detail="Vulnerability not found")
            
            # Parse result
            vulnerability = {
                "vuln_id": result[1],
                "vulnerability_type": result[2],
                "severity": result[3],
                "title": result[4],
                "description": result[5],
                "url": result[6],
                "method": result[7],
                "parameter": result[8],
                "payload": result[9],
                "evidence": result[10],
                "risk_score": result[11],
                "cwe_id": result[12],
                "owasp_category": result[13],
                "remediation": json.loads(result[14]) if result[14] else [],
                "scan_info": {
                    "target_url": result[16],
                    "scan_type": result[17],
                    "scan_time": result[18]
                }
            }
            
            return vulnerability
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"❌ Failed to get vulnerability details: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/owasp/categories", response_model=Dict[str, Any])
async def get_owasp_categories():
    """Get OWASP Top 10 2021 categories information"""
    try:
        categories = {
            "A01:2021": {
                "name": "Broken Access Control",
                "description": "Restrictions on what authenticated users are allowed to do are often not properly enforced.",
                "common_weaknesses": ["CWE-200", "CWE-201", "CWE-352"],
                "prevention": [
                    "Implement proper access control mechanisms",
                    "Use deny by default principle",
                    "Log access control failures and alert administrators"
                ]
            },
            "A02:2021": {
                "name": "Cryptographic Failures",
                "description": "Many web applications and APIs do not properly protect sensitive data.",
                "common_weaknesses": ["CWE-259", "CWE-327", "CWE-331"],
                "prevention": [
                    "Encrypt all sensitive data at rest and in transit",
                    "Use up-to-date and strong standard algorithms",
                    "Ensure proper key management"
                ]
            },
            "A03:2021": {
                "name": "Injection",
                "description": "An application is vulnerable to attack when user-supplied data is not validated, filtered, or sanitized.",
                "common_weaknesses": ["CWE-79", "CWE-89", "CWE-73"],
                "prevention": [
                    "Use parameterized queries or prepared statements",
                    "Validate all input data",
                    "Use allowlist server-side input validation"
                ]
            },
            "A04:2021": {
                "name": "Insecure Design",
                "description": "Risks related to design flaws and missing or ineffective control design.",
                "common_weaknesses": ["CWE-209", "CWE-256", "CWE-501"],
                "prevention": [
                    "Establish secure development lifecycle",
                    "Use threat modeling for critical flows",
                    "Write unit and integration tests"
                ]
            },
            "A05:2021": {
                "name": "Security Misconfiguration",
                "description": "Security misconfiguration is commonly a result of insecure default configurations.",
                "common_weaknesses": ["CWE-16", "CWE-611"],
                "prevention": [
                    "Implement secure installation processes",
                    "Remove unused features and frameworks",
                    "Review cloud storage permissions"
                ]
            },
            "A06:2021": {
                "name": "Vulnerable and Outdated Components",
                "description": "Components run with the same privileges as the application itself.",
                "common_weaknesses": ["CWE-1104"],
                "prevention": [
                    "Remove unused dependencies and features",
                    "Continuously inventory component versions",
                    "Monitor for security vulnerabilities"
                ]
            },
            "A07:2021": {
                "name": "Identification and Authentication Failures",
                "description": "Application functions related to authentication and session management are often implemented incorrectly.",
                "common_weaknesses": ["CWE-297", "CWE-287", "CWE-384"],
                "prevention": [
                    "Implement multi-factor authentication",
                    "Do not ship with default credentials",
                    "Use weak password checks"
                ]
            },
            "A08:2021": {
                "name": "Software and Data Integrity Failures",
                "description": "Software and data integrity failures relate to code and infrastructure that does not protect against integrity violations.",
                "common_weaknesses": ["CWE-829", "CWE-494"],
                "prevention": [
                    "Use digital signatures or similar mechanisms",
                    "Ensure CI/CD pipeline has proper segregation",
                    "Ensure unsigned or unencrypted serialized data is not sent to untrusted clients"
                ]
            },
            "A09:2021": {
                "name": "Security Logging and Monitoring Failures",
                "description": "Insufficient logging and monitoring, coupled with missing or ineffective integration with incident response.",
                "common_weaknesses": ["CWE-778", "CWE-117"],
                "prevention": [
                    "Log all login, access control, and server-side input validation failures",
                    "Ensure log data is encoded correctly",
                    "Establish effective monitoring and alerting"
                ]
            },
            "A10:2021": {
                "name": "Server-Side Request Forgery (SSRF)",
                "description": "SSRF flaws occur whenever a web application is fetching a remote resource without validating the user-supplied URL.",
                "common_weaknesses": ["CWE-918"],
                "prevention": [
                    "Sanitize and validate all client-supplied input data",
                    "Enforce URL schema, port, and destination with a positive allow list",
                    "Do not send raw responses to clients"
                ]
            }
        }
        
        return {
            "owasp_version": "2021",
            "categories": categories,
            "total_categories": len(categories)
        }
        
    except Exception as e:
        logger.error(f"❌ Failed to get OWASP categories: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.delete("/scan/{scan_id}", response_model=Dict[str, Any])
async def delete_web_vulnerability_scan(
    scan_id: str,
    scanner = Depends(get_scanner)
):
    """Delete a web vulnerability scan and its results"""
    try:
        with scanner.db_manager.get_connection() as conn:
            cursor = conn.cursor()
            
            # Check if scan exists
            cursor.execute("SELECT COUNT(*) FROM web_vulnerability_scans WHERE scan_id = ?", (scan_id,))
            if cursor.fetchone()[0] == 0:
                raise HTTPException(status_code=404, detail="Scan not found")
            
            # Delete vulnerabilities first (foreign key constraint)
            cursor.execute("DELETE FROM web_vulnerabilities WHERE scan_id = ?", (scan_id,))
            vulnerabilities_deleted = cursor.rowcount
            
            # Delete scan record
            cursor.execute("DELETE FROM web_vulnerability_scans WHERE scan_id = ?", (scan_id,))
            scan_deleted = cursor.rowcount
            
            conn.commit()
            
            # Remove from active scans if present
            if scan_id in scanner._active_scans:
                del scanner._active_scans[scan_id]
            
            logger.info(f"🗑️ Deleted web vulnerability scan {scan_id}")
            
            return {
                "status": "success",
                "message": f"Web vulnerability scan {scan_id} deleted successfully",
                "deleted_records": {
                    "scan": scan_deleted,
                    "vulnerabilities": vulnerabilities_deleted
                }
            }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"❌ Failed to delete web vulnerability scan: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/health", response_model=Dict[str, Any])
async def web_vulnerability_health_check(scanner = Depends(get_scanner)):
    """Health check for web vulnerability scanner"""
    try:
        # Test database connection
        with scanner.db_manager.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM web_vulnerability_scans")
            scans_count = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM web_vulnerabilities")
            vulnerabilities_count = cursor.fetchone()[0]
        
        # Check active scans
        active_scans = len(scanner._active_scans)
        
        return {
            "status": "healthy",
            "web_vulnerability_scanner": "operational",
            "database": {
                "connected": True,
                "total_scans": scans_count,
                "total_vulnerabilities": vulnerabilities_count
            },
            "active_scans": active_scans,
            "supported_scan_types": ["quick", "comprehensive", "owasp", "ssl", "headers"],
            "owasp_version": "2021",
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"❌ Web vulnerability scanner health check failed: {e}")
        raise HTTPException(status_code=500, detail=f"Health check failed: {e}")

if __name__ == "__main__":
    print("Web Vulnerability Scanner API module loaded successfully")
    print("Available endpoints:")
    for route in router.routes:
        if hasattr(route, 'methods') and hasattr(route, 'path'):
            methods = list(route.methods)
            print(f"  {methods[0]:6} {route.path}")