#!/usr/bin/env python3
"""
CyberSec Assistant Portable - Vulnerability Scanner V1.0
Phase 4.1: Advanced CVE Scanner with NIST/MITRE Integration
Architecture: FastAPI + CVE Database + Exploit Detection + CVSS Scoring
"""

import os
import json
import sqlite3
import asyncio
import logging
import requests
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from pathlib import Path
import re
import xml.etree.ElementTree as ET
from dataclasses import dataclass, asdict
import gzip
from urllib.parse import urlparse

# Import existing modules for integration
from stealth_engine import get_global_stealth_engine
from database_manager import get_database_manager

logger = logging.getLogger(__name__)

@dataclass
class CVEEntry:
    """CVE Entry data structure"""
    cve_id: str
    description: str
    cvss_score: float
    cvss_vector: str
    severity: str
    published_date: str
    modified_date: str
    cpe_configurations: List[str]
    references: List[str]
    exploit_available: bool = False
    exploit_sources: List[str] = None

@dataclass 
class VulnerabilityMatch:
    """Vulnerability match result"""
    target_host: str
    target_port: int
    service_name: str
    service_version: str
    cve_entries: List[CVEEntry]
    confidence_score: float
    risk_level: str
    recommendations: List[str]

@dataclass
class VulnerabilityScan:
    """Vulnerability scan configuration and results"""
    scan_id: str
    target: str
    scan_type: str
    status: str
    start_time: datetime
    end_time: Optional[datetime] = None
    results: List[VulnerabilityMatch] = None
    total_vulnerabilities: int = 0
    critical_count: int = 0
    high_count: int = 0
    medium_count: int = 0
    low_count: int = 0

class CVEDatabase:
    """CVE Database manager with NIST NVD integration"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.db_manager = get_database_manager(db_path)
        self.base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.cve_feeds_url = "https://nvd.nist.gov/feeds/json/cve/1.1"
        self._init_cve_tables()
    
    def _init_cve_tables(self):
        """Initialize CVE database tables"""
        try:
            with self.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                
                # CVE entries table
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS cve_entries (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        cve_id TEXT UNIQUE NOT NULL,
                        description TEXT,
                        cvss_score REAL,
                        cvss_vector TEXT,
                        severity TEXT,
                        published_date TEXT,
                        modified_date TEXT,
                        cpe_configurations TEXT,
                        reference_urls TEXT,
                        exploit_available BOOLEAN DEFAULT FALSE,
                        exploit_sources TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # CPE (Common Platform Enumeration) table
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS cpe_entries (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        cpe_uri TEXT UNIQUE NOT NULL,
                        vendor TEXT,
                        product TEXT,
                        version TEXT,
                        update_info TEXT,
                        edition TEXT,
                        language TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # Vulnerability scan results
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS vulnerability_scans (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        scan_id TEXT UNIQUE NOT NULL,
                        target TEXT NOT NULL,
                        scan_type TEXT NOT NULL,
                        status TEXT NOT NULL,
                        start_time TIMESTAMP,
                        end_time TIMESTAMP,
                        total_vulnerabilities INTEGER DEFAULT 0,
                        critical_count INTEGER DEFAULT 0,
                        high_count INTEGER DEFAULT 0,
                        medium_count INTEGER DEFAULT 0,
                        low_count INTEGER DEFAULT 0,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # Vulnerability matches
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS vulnerability_matches (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        scan_id TEXT NOT NULL,
                        target_host TEXT NOT NULL,
                        target_port INTEGER NOT NULL,
                        service_name TEXT,
                        service_version TEXT,
                        cve_id TEXT NOT NULL,
                        confidence_score REAL,
                        risk_level TEXT,
                        recommendations TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (scan_id) REFERENCES vulnerability_scans(scan_id),
                        FOREIGN KEY (cve_id) REFERENCES cve_entries(cve_id)
                    )
                """)
                
                # Exploit database
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS exploit_database (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        exploit_id TEXT UNIQUE NOT NULL,
                        cve_id TEXT,
                        title TEXT,
                        description TEXT,
                        platform TEXT,
                        exploit_type TEXT,
                        port INTEGER,
                        shellcode TEXT,
                        source_url TEXT,
                        author TEXT,
                        date_published TEXT,
                        verified BOOLEAN DEFAULT FALSE,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (cve_id) REFERENCES cve_entries(cve_id)
                    )
                """)
                
                conn.commit()
                logger.info("✅ CVE database tables initialized successfully")
                
        except Exception as e:
            logger.error(f"❌ Failed to initialize CVE tables: {e}")
            raise
    
    async def update_cve_database(self, days_back: int = 7) -> Dict[str, Any]:
        """Update CVE database from NIST NVD"""
        try:
            stealth_engine = get_global_stealth_engine()
            session = stealth_engine.create_stealth_session()
            end_date = datetime.now()
            start_date = end_date - timedelta(days=days_back)
            
            # Format dates for API
            start_str = start_date.strftime("%Y-%m-%dT%H:%M:%S.000")
            end_str = end_date.strftime("%Y-%m-%dT%H:%M:%S.000")
            
            params = {
                "pubStartDate": start_str,
                "pubEndDate": end_str,
                "resultsPerPage": 2000
            }
            
            logger.info(f"🔄 Updating CVE database from {start_str} to {end_str}")
            
            response = await session.get(self.base_url, params=params)
            response.raise_for_status()
            
            data = response.json()
            vulnerabilities = data.get('vulnerabilities', [])
            
            updated_count = 0
            for vuln_data in vulnerabilities:
                cve_item = vuln_data.get('cve', {})
                cve_id = cve_item.get('id', '')
                
                if cve_id:
                    await self._process_cve_entry(cve_item)
                    updated_count += 1
            
            # Update exploit database
            await self._update_exploit_database()
            
            return {
                "status": "success",
                "updated_cves": updated_count,
                "date_range": f"{start_str} to {end_str}",
                "total_vulnerabilities": len(vulnerabilities)
            }
            
        except Exception as e:
            logger.error(f"❌ CVE database update failed: {e}")
            return {"status": "error", "message": str(e)}
    
    async def _process_cve_entry(self, cve_item: Dict) -> None:
        """Process and store a single CVE entry"""
        try:
            cve_id = cve_item.get('id', '')
            descriptions = cve_item.get('descriptions', [])
            description = ""
            
            for desc in descriptions:
                if desc.get('lang') == 'en':
                    description = desc.get('value', '')
                    break
            
            # Extract CVSS scores
            metrics = cve_item.get('metrics', {})
            cvss_score = 0.0
            cvss_vector = ""
            severity = "UNKNOWN"
            
            # Try CVSS v3.1 first, then v3.0, then v2.0
            for version in ['cvssMetricV31', 'cvssMetricV30', 'cvssMetricV2']:
                if version in metrics and metrics[version]:
                    metric = metrics[version][0]  # Take first metric
                    cvss_data = metric.get('cvssData', {})
                    cvss_score = cvss_data.get('baseScore', 0.0)
                    cvss_vector = cvss_data.get('vectorString', '')
                    severity = cvss_data.get('baseSeverity', 'UNKNOWN')
                    break
            
            # Extract CPE configurations
            configurations = cve_item.get('configurations', [])
            cpe_configs = []
            for config in configurations:
                for node in config.get('nodes', []):
                    for cpe_match in node.get('cpeMatch', []):
                        if cpe_match.get('vulnerable', False):
                            cpe_configs.append(cpe_match.get('criteria', ''))
            
            # Extract references
            references = []
            for ref in cve_item.get('references', []):
                references.append(ref.get('url', ''))
            
            # Store in database
            with self.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                
                cursor.execute("""
                    INSERT OR REPLACE INTO cve_entries 
                    (cve_id, description, cvss_score, cvss_vector, severity, 
                     published_date, modified_date, cpe_configurations, references, updated_at)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
                """, (
                    cve_id, description, cvss_score, cvss_vector, severity,
                    cve_item.get('published', ''), cve_item.get('lastModified', ''),
                    json.dumps(cpe_configs), json.dumps(references)
                ))
                
                conn.commit()
                
        except Exception as e:
            logger.error(f"❌ Failed to process CVE entry {cve_id}: {e}")
    
    async def _update_exploit_database(self) -> None:
        """Update exploit database from public sources"""
        try:
            # This would integrate with Exploit-DB API or scrape public sources
            # For now, we'll add a placeholder implementation
            logger.info("🔄 Updating exploit database...")
            
            # Add basic exploit detection logic here
            # This could integrate with:
            # - Exploit-DB
            # - Metasploit modules
            # - Custom exploit collections
            
        except Exception as e:
            logger.error(f"❌ Exploit database update failed: {e}")
    
    def search_cve_by_service(self, service: str, version: str = None) -> List[CVEEntry]:
        """Search CVEs by service name and version"""
        try:
            with self.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                
                # Build search query
                if version:
                    search_pattern = f"%{service}%{version}%"
                else:
                    search_pattern = f"%{service}%"
                
                cursor.execute("""
                    SELECT cve_id, description, cvss_score, cvss_vector, severity,
                           published_date, modified_date, cpe_configurations, references,
                           exploit_available, exploit_sources
                    FROM cve_entries
                    WHERE cpe_configurations LIKE ? OR description LIKE ?
                    ORDER BY cvss_score DESC
                    LIMIT 50
                """, (search_pattern, search_pattern))
                
                results = cursor.fetchall()
                
                cve_entries = []
                for row in results:
                    cve_entry = CVEEntry(
                        cve_id=row[0],
                        description=row[1],
                        cvss_score=row[2] or 0.0,
                        cvss_vector=row[3] or "",
                        severity=row[4] or "UNKNOWN",
                        published_date=row[5] or "",
                        modified_date=row[6] or "",
                        cpe_configurations=json.loads(row[7]) if row[7] else [],
                        references=json.loads(row[8]) if row[8] else [],
                        exploit_available=bool(row[9]),
                        exploit_sources=json.loads(row[10]) if row[10] else []
                    )
                    cve_entries.append(cve_entry)
                
                return cve_entries
                
        except Exception as e:
            logger.error(f"❌ CVE search failed: {e}")
            return []

class VulnerabilityScanner:
    """Main vulnerability scanner class"""
    
    def __init__(self, database_path: str):
        self.db_path = database_path
        self.cve_db = CVEDatabase(database_path)
        self.db_manager = get_database_manager(database_path)
        self._active_scans = {}
    
    async def start_vulnerability_scan(self, target: str, scan_type: str = "comprehensive") -> str:
        """Start a vulnerability scan"""
        try:
            scan_id = f"vulnscan_{int(datetime.now().timestamp())}"
            
            scan = VulnerabilityScan(
                scan_id=scan_id,
                target=target,
                scan_type=scan_type,
                status="running",
                start_time=datetime.now()
            )
            
            self._active_scans[scan_id] = scan
            
            # Store scan in database
            with self.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    INSERT INTO vulnerability_scans 
                    (scan_id, target, scan_type, status, start_time)
                    VALUES (?, ?, ?, ?, ?)
                """, (scan_id, target, scan_type, "running", scan.start_time.isoformat()))
                conn.commit()
            
            # Start scan in background
            asyncio.create_task(self._execute_vulnerability_scan(scan_id))
            
            logger.info(f"🚀 Started vulnerability scan {scan_id} for target {target}")
            return scan_id
            
        except Exception as e:
            logger.error(f"❌ Failed to start vulnerability scan: {e}")
            raise
    
    async def _execute_vulnerability_scan(self, scan_id: str) -> None:
        """Execute the vulnerability scan"""
        try:
            scan = self._active_scans[scan_id]
            scan.status = "scanning"
            
            # Get network scan results to analyze
            network_services = await self._get_network_services(scan.target)
            
            vulnerability_matches = []
            
            for service in network_services:
                matches = await self._analyze_service_vulnerabilities(
                    service['host'], 
                    service['port'], 
                    service['service'], 
                    service.get('version', '')
                )
                vulnerability_matches.extend(matches)
            
            # Process results
            scan.results = vulnerability_matches
            scan.total_vulnerabilities = len(vulnerability_matches)
            
            # Count by severity
            for match in vulnerability_matches:
                for cve in match.cve_entries:
                    if cve.cvss_score >= 9.0:
                        scan.critical_count += 1
                    elif cve.cvss_score >= 7.0:
                        scan.high_count += 1
                    elif cve.cvss_score >= 4.0:
                        scan.medium_count += 1
                    else:
                        scan.low_count += 1
            
            scan.status = "completed"
            scan.end_time = datetime.now()
            
            # Update database
            await self._save_scan_results(scan)
            
            logger.info(f"✅ Vulnerability scan {scan_id} completed. Found {scan.total_vulnerabilities} vulnerabilities")
            
        except Exception as e:
            logger.error(f"❌ Vulnerability scan {scan_id} failed: {e}")
            if scan_id in self._active_scans:
                self._active_scans[scan_id].status = "failed"
    
    async def _get_network_services(self, target: str) -> List[Dict]:
        """Get network services from previous scans"""
        try:
            with self.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                
                # Get recent port scan results for this target
                cursor.execute("""
                    SELECT DISTINCT target, port, service, version
                    FROM port_scans 
                    WHERE target = ? AND state = 'open'
                    ORDER BY created_at DESC
                    LIMIT 100
                """, (target,))
                
                results = cursor.fetchall()
                
                services = []
                for row in results:
                    services.append({
                        'host': row[0],
                        'port': row[1],
                        'service': row[2] or 'unknown',
                        'version': row[3] or ''
                    })
                
                return services
                
        except Exception as e:
            logger.error(f"❌ Failed to get network services: {e}")
            return []
    
    async def _analyze_service_vulnerabilities(self, host: str, port: int, service: str, version: str) -> List[VulnerabilityMatch]:
        """Analyze vulnerabilities for a specific service"""
        try:
            # Search for CVEs related to this service
            cve_entries = self.cve_db.search_cve_by_service(service, version)
            
            if not cve_entries:
                return []
            
            # Calculate confidence score based on version matching
            confidence_score = 0.5  # Base confidence
            if version and version != "unknown":
                confidence_score = 0.8  # Higher confidence with version
            
            # Determine risk level based on highest CVSS score
            max_cvss = max([cve.cvss_score for cve in cve_entries], default=0.0)
            if max_cvss >= 9.0:
                risk_level = "CRITICAL"
            elif max_cvss >= 7.0:
                risk_level = "HIGH"
            elif max_cvss >= 4.0:
                risk_level = "MEDIUM"
            else:
                risk_level = "LOW"
            
            # Generate recommendations
            recommendations = self._generate_recommendations(service, version, cve_entries)
            
            match = VulnerabilityMatch(
                target_host=host,
                target_port=port,
                service_name=service,
                service_version=version,
                cve_entries=cve_entries,
                confidence_score=confidence_score,
                risk_level=risk_level,
                recommendations=recommendations
            )
            
            return [match]
            
        except Exception as e:
            logger.error(f"❌ Service vulnerability analysis failed: {e}")
            return []
    
    def _generate_recommendations(self, service: str, version: str, cves: List[CVEEntry]) -> List[str]:
        """Generate security recommendations"""
        recommendations = []
        
        if cves:
            recommendations.append(f"Update {service} to the latest version")
            recommendations.append("Apply security patches immediately")
            recommendations.append("Consider network segmentation")
            
            if any(cve.exploit_available for cve in cves):
                recommendations.append("⚠️ Active exploits available - URGENT patching required")
            
            high_risk_cves = [cve for cve in cves if cve.cvss_score >= 7.0]
            if high_risk_cves:
                recommendations.append(f"Address {len(high_risk_cves)} high/critical severity vulnerabilities")
        
        return recommendations
    
    async def _save_scan_results(self, scan: VulnerabilityScan) -> None:
        """Save scan results to database"""
        try:
            with self.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                
                # Update scan record
                cursor.execute("""
                    UPDATE vulnerability_scans 
                    SET status = ?, end_time = ?, total_vulnerabilities = ?,
                        critical_count = ?, high_count = ?, medium_count = ?, low_count = ?,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE scan_id = ?
                """, (
                    scan.status, scan.end_time.isoformat() if scan.end_time else None,
                    scan.total_vulnerabilities, scan.critical_count, scan.high_count,
                    scan.medium_count, scan.low_count, scan.scan_id
                ))
                
                # Save vulnerability matches
                if scan.results:
                    for match in scan.results:
                        for cve in match.cve_entries:
                            cursor.execute("""
                                INSERT INTO vulnerability_matches
                                (scan_id, target_host, target_port, service_name, service_version,
                                 cve_id, confidence_score, risk_level, recommendations)
                                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                            """, (
                                scan.scan_id, match.target_host, match.target_port,
                                match.service_name, match.service_version, cve.cve_id,
                                match.confidence_score, match.risk_level,
                                json.dumps(match.recommendations)
                            ))
                
                conn.commit()
                
        except Exception as e:
            logger.error(f"❌ Failed to save scan results: {e}")
    
    def get_scan_status(self, scan_id: str) -> Dict[str, Any]:
        """Get scan status and results"""
        try:
            if scan_id in self._active_scans:
                scan = self._active_scans[scan_id]
                return {
                    "scan_id": scan_id,
                    "target": scan.target,
                    "status": scan.status,
                    "start_time": scan.start_time.isoformat(),
                    "end_time": scan.end_time.isoformat() if scan.end_time else None,
                    "total_vulnerabilities": scan.total_vulnerabilities,
                    "critical_count": scan.critical_count,
                    "high_count": scan.high_count,
                    "medium_count": scan.medium_count,
                    "low_count": scan.low_count
                }
            
            # Check database for completed scans
            with self.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    SELECT scan_id, target, scan_type, status, start_time, end_time,
                           total_vulnerabilities, critical_count, high_count, medium_count, low_count
                    FROM vulnerability_scans
                    WHERE scan_id = ?
                """, (scan_id,))
                
                result = cursor.fetchone()
                if result:
                    return {
                        "scan_id": result[0],
                        "target": result[1],
                        "scan_type": result[2],
                        "status": result[3],
                        "start_time": result[4],
                        "end_time": result[5],
                        "total_vulnerabilities": result[6] or 0,
                        "critical_count": result[7] or 0,
                        "high_count": result[8] or 0,
                        "medium_count": result[9] or 0,
                        "low_count": result[10] or 0
                    }
            
            return {"error": "Scan not found"}
            
        except Exception as e:
            logger.error(f"❌ Failed to get scan status: {e}")
            return {"error": str(e)}
    
    def get_vulnerability_details(self, scan_id: str) -> List[Dict]:
        """Get detailed vulnerability information for a scan"""
        try:
            with self.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                
                cursor.execute("""
                    SELECT vm.target_host, vm.target_port, vm.service_name, vm.service_version,
                           vm.confidence_score, vm.risk_level, vm.recommendations,
                           ce.cve_id, ce.description, ce.cvss_score, ce.severity,
                           ce.published_date, ce.references, ce.exploit_available
                    FROM vulnerability_matches vm
                    JOIN cve_entries ce ON vm.cve_id = ce.cve_id
                    WHERE vm.scan_id = ?
                    ORDER BY ce.cvss_score DESC
                """, (scan_id,))
                
                results = cursor.fetchall()
                
                vulnerabilities = []
                for row in results:
                    vuln = {
                        "target_host": row[0],
                        "target_port": row[1],
                        "service_name": row[2],
                        "service_version": row[3],
                        "confidence_score": row[4],
                        "risk_level": row[5],
                        "recommendations": json.loads(row[6]) if row[6] else [],
                        "cve": {
                            "cve_id": row[7],
                            "description": row[8],
                            "cvss_score": row[9],
                            "severity": row[10],
                            "published_date": row[11],
                            "references": json.loads(row[12]) if row[12] else [],
                            "exploit_available": bool(row[13])
                        }
                    }
                    vulnerabilities.append(vuln)
                
                return vulnerabilities
                
        except Exception as e:
            logger.error(f"❌ Failed to get vulnerability details: {e}")
            return []

# Global instance
_vulnerability_scanner = None

def get_vulnerability_scanner(database_path: str = None) -> VulnerabilityScanner:
    """Get global vulnerability scanner instance"""
    global _vulnerability_scanner
    
    if _vulnerability_scanner is None:
        if not database_path:
            # Use default path from main application
            from pathlib import Path
            portable_dir = Path(__file__).parent.parent.absolute()
            database_path = str(portable_dir / "data" / "cybersec.db")
        
        _vulnerability_scanner = VulnerabilityScanner(database_path)
    
    return _vulnerability_scanner

if __name__ == "__main__":
    # Test the vulnerability scanner
    async def test_scanner():
        scanner = get_vulnerability_scanner()
        
        # Update CVE database
        result = await scanner.cve_db.update_cve_database(days_back=1)
        print(f"CVE Database Update: {result}")
        
        # Search for specific vulnerabilities
        cves = scanner.cve_db.search_cve_by_service("apache", "2.4")
        print(f"Found {len(cves)} CVEs for Apache 2.4")
        
        for cve in cves[:5]:  # Show first 5
            print(f"- {cve.cve_id}: Score {cve.cvss_score} - {cve.description[:100]}...")
    
    asyncio.run(test_scanner())